
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="icon" type="image/ico" href="images/favicon.ico">
    <title>Gunrock</title>

    <script type="text/javascript" src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@4"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <style media="screen">
      /* Add space between vega-embed links */
      /* http://vega.github.io/vega-tutorials/airports/ */
      .vega-embed .vega-actions a {
        margin-left: 1em;
        visibility: hidden;
      }
      .vega-embed:hover .vega-actions a {
        visibility: visible;
      }
    </style>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <a href="https://gunrock.github.io/">
        <img src="images/logo.png" class="logo" alt="Logo" />
      </a>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc" class="toc-list-h1">
          <li>
            <a href="#gunrock-gpu-graph-analytics" class="toc-h1 toc-link" data-title="Gunrock: GPU Graph Analytics">GUNROCK: GPU GRAPH ANALYTICS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#quick-start-guide" class="toc-h2 toc-link" data-title="Quick Start Guide">Quick Start Guide</a>
                  </li>
                  <li>
                    <a href="#getting-started-with-gunrock" class="toc-h2 toc-link" data-title="Getting Started with Gunrock">Getting Started with Gunrock</a>
                  </li>
                  <li>
                    <a href="#copyright-and-license" class="toc-h2 toc-link" data-title="Copyright and License">Copyright and License</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#overview" class="toc-h1 toc-link" data-title="Overview">OVERVIEW</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#what-is-gunrock" class="toc-h2 toc-link" data-title="What is Gunrock?">What is <em>Gunrock</em>?</a>
                  </li>
                  <li>
                    <a href="#who-may-use-gunrock" class="toc-h2 toc-link" data-title="Who may use Gunrock?">Who may use <em>Gunrock</em>?</a>
                  </li>
                  <li>
                    <a href="#why-use-gunrock" class="toc-h2 toc-link" data-title="Why use Gunrock?">Why use <em>Gunrock</em>?</a>
                  </li>
                  <li>
                    <a href="#what-does-gunrock-not-do" class="toc-h2 toc-link" data-title="What does Gunrock not do?">What does Gunrock not do?</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#programming-model" class="toc-h1 toc-link" data-title="Programming Model">PROGRAMMING MODEL</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#operators" class="toc-h2 toc-link" data-title="Operators">Operators</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#gunrock-39-s-application-cases" class="toc-h1 toc-link" data-title="Gunrock's Application Cases">GUNROCK'S APPLICATION CASES</a>
          </li>
          <li>
            <a href="#building-gunrock" class="toc-h1 toc-link" data-title="Building Gunrock">BUILDING GUNROCK</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#installation" class="toc-h2 toc-link" data-title="Installation">Installation</a>
                  </li>
                  <li>
                    <a href="#prerequisites" class="toc-h2 toc-link" data-title="Prerequisites">Prerequisites</a>
                  </li>
                  <li>
                    <a href="#compilation" class="toc-h2 toc-link" data-title="Compilation">Compilation</a>
                  </li>
                  <li>
                    <a href="#generating-datasets" class="toc-h2 toc-link" data-title="Generating Datasets">Generating Datasets</a>
                  </li>
                  <li>
                    <a href="#hardware" class="toc-h2 toc-link" data-title="Hardware">Hardware</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#methodology" class="toc-h1 toc-link" data-title="Methodology">METHODOLOGY</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#methodology-for-graph-analytics-performance" class="toc-h2 toc-link" data-title="Methodology for Graph Analytics Performance">Methodology for Graph Analytics Performance</a>
                  </li>
                  <li>
                    <a href="#breadth-first-search-bfs" class="toc-h2 toc-link" data-title="Breadth-First Search (BFS)">Breadth-First Search (BFS)</a>
                  </li>
                  <li>
                    <a href="#single-source-shortest-path-sssp" class="toc-h2 toc-link" data-title="Single Source Shortest Path (SSSP)">Single Source Shortest Path (SSSP)</a>
                  </li>
                  <li>
                    <a href="#betweenness-centrality-bc" class="toc-h2 toc-link" data-title="Betweenness Centrality (BC)">Betweenness Centrality (BC)</a>
                  </li>
                  <li>
                    <a href="#pagerank-pr" class="toc-h2 toc-link" data-title="PageRank (PR)">PageRank (PR)</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#results-and-analysis" class="toc-h1 toc-link" data-title="Results and Analysis">RESULTS AND ANALYSIS</a>
          </li>
          <li>
            <a href="#publications" class="toc-h1 toc-link" data-title="Publications">PUBLICATIONS</a>
          </li>
          <li>
            <a href="#presentations" class="toc-h1 toc-link" data-title="Presentations">PRESENTATIONS</a>
          </li>
          <li>
            <a href="#road-map" class="toc-h1 toc-link" data-title="Road Map">ROAD MAP</a>
          </li>
          <li>
            <a href="#possible-gunrock-projects" class="toc-h1 toc-link" data-title="Possible Gunrock projects">POSSIBLE GUNROCK PROJECTS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#infrastructure-projects" class="toc-h2 toc-link" data-title="Infrastructure projects">Infrastructure projects</a>
                  </li>
                  <li>
                    <a href="#research-projects" class="toc-h2 toc-link" data-title="Research projects">Research projects</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#gunrock-developers" class="toc-h1 toc-link" data-title="Gunrock Developers">GUNROCK DEVELOPERS</a>
          </li>
          <li>
            <a href="#frequently-asked-questions" class="toc-h1 toc-link" data-title="Frequently Asked Questions">FREQUENTLY ASKED QUESTIONS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#what-does-it-do" class="toc-h2 toc-link" data-title="What does it do?">What does it do?</a>
                  </li>
                  <li>
                    <a href="#how-does-it-do-it" class="toc-h2 toc-link" data-title="How does it do it?">How does it do it?</a>
                  </li>
                  <li>
                    <a href="#who-should-want-this" class="toc-h2 toc-link" data-title="Who should want this?">Who should want this?</a>
                  </li>
                  <li>
                    <a href="#when-would-gunrock-be-a-bad-choice" class="toc-h2 toc-link" data-title="When would Gunrock be a bad choice?">When would Gunrock be a bad choice?</a>
                  </li>
                  <li>
                    <a href="#what-is-the-skill-set-users-need-to-use-it" class="toc-h2 toc-link" data-title="What is the skill set users need to use it?">What is the skill set users need to use it?</a>
                  </li>
                  <li>
                    <a href="#what-platforms-languages-do-people-need-to-know-in-order-to-modify-or-integrate-it-with-other-tools" class="toc-h2 toc-link" data-title="What platforms/languages do people need to know in order to modify or integrate it with other tools?">What platforms/languages do people need to know in order to modify or integrate it with other tools?</a>
                  </li>
                  <li>
                    <a href="#why-would-someone-want-this" class="toc-h2 toc-link" data-title="Why would someone want this?">Why would someone want this?</a>
                  </li>
                  <li>
                    <a href="#how-is-it-better-than-the-current-state-of-the-art" class="toc-h2 toc-link" data-title="How is it better than the current state of the art?">How is it better than the current state of the art?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-get-it" class="toc-h2 toc-link" data-title="How would someone get it?">How would someone get it?</a>
                  </li>
                  <li>
                    <a href="#is-a-user-account-required" class="toc-h2 toc-link" data-title="Is a user account required?">Is a user account required?</a>
                  </li>
                  <li>
                    <a href="#are-all-of-its-components-dependencies-easy-to-find" class="toc-h2 toc-link" data-title="Are all of its components/dependencies easy to find?">Are all of its components/dependencies easy to find?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-install-it" class="toc-h2 toc-link" data-title="How would someone install it?">How would someone install it?</a>
                  </li>
                  <li>
                    <a href="#can-anyone-install-it-do-they-need-it-help" class="toc-h2 toc-link" data-title="Can anyone install it? Do they need IT help?">Can anyone install it? Do they need IT help?</a>
                  </li>
                  <li>
                    <a href="#does-this-process-actually-work-all-the-time-on-all-systems-specified" class="toc-h2 toc-link" data-title="Does this process actually work? All the time? On all systems specified?">Does this process actually work? All the time? On all systems specified?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-test-that-it-39-s-working-with-provided-sample-data" class="toc-h2 toc-link" data-title="How would someone test that it's working with provided sample data?">How would someone test that it's working with provided sample data?</a>
                  </li>
                  <li>
                    <a href="#is-the-quot-using-quot-of-sample-data-clear" class="toc-h2 toc-link" data-title="Is the "using" of sample data clear?">Is the "using" of sample data clear?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-use-it-with-their-own-data" class="toc-h2 toc-link" data-title="How would someone use it with their own data?">How would someone use it with their own data?</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#release-notes" class="toc-h1 toc-link" data-title="Release Notes">RELEASE NOTES</a>
          </li>
          <li>
            <a href="#acknowledgments" class="toc-h1 toc-link" data-title="Acknowledgments">ACKNOWLEDGMENTS</a>
          </li>
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/gunrock/gunrock'>Gunrock; GPU Graph Analytics</a></li>
            <li>Gunrock © 2019 The Regents of the University of California.</li>
        </ul>
    </div>
    <div class="page-wrapper">

        <!-- <div class="dark-box"></div> -->

      <div class="content">
        <!-- start: gunrock's header -->

<p align="center">
  <a href="https://github.com/gunrock/gunrock/"><img src="https://github.com/gunrock/docs/raw/master/source/images/GunrockLogo150px.png"></a>
  <br>
  <a href="https://github.com/gunrock/gunrock/releases/tag/v1.0"><img src="https://img.shields.io/badge/gunrock-v1.0-blue.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAIjklEQVRIDQXBaZCeBWEA4Oc9vnN3v93sbrKbhGxCIMVASERQSCt0BCo4lOGonVirMOPR45cVbS3t1B8OYy%2B1WKdFtKPiqB162LHjdAZqKQUBwyEBYgKJuZYku9kju%2Fvtd79XnycoAHD0NznzEDe1OT1gOmDhLLMhN5RxLcEtrOxn%2BX6VbTOu6Z52oVh2auOHqf2CE%2BucmWXuFfbuo3w5UcpShWLAxhUuv5UQAAAAACDMSdus3EP4Hu%2BeHLG0dMgLSdfJZNID0SKQIisQAAAAADEAAAAEyDHIyAqCNp0%2FNDR8wTOdFZXpHT7U6rizvezLC4cllZJ%2FCiLdSkha0E%2BICiLkAQEAQgAAUJAVJDlRyoaGLc1Rn2w1fbd81FxnXXWy7%2FbGwOPdno%2BEQ462m%2F5%2BYUknWnNie8OXLt%2FttjgSV2OKgjAjKSgCIAYAAWnCANWQNGCo5g%2FKQx7pJ6Rt6mXCgG7f7k7hyaCqESY25jnlOmluZ8Rntl%2FiM3nuZNj0%2Bf7A9VM0VkJ%2FJnBeQFAA4Pg9nH%2FQ1u0XPRbGrhaaTbquKwrKAWEoa0f%2BNkztDsruynPz1dx00TZb2%2BKuYs1lacfvGfH%2BQU46ICqIQ0oRSSoNYu%2Fa9j5vhG7CTbiKiyM0Bn4UF24p2uJ01bVZxFBIJ%2Fd1I8ZfO%2BPB5pC7J%2Bv%2BJu6abrcdmeq4cXSTQ%2FWL%2Fn1r1W3ry3Z3VrxQKhPHfnluWHS8sLnZF8e5b%2FdfJfYQUmxgvO1TxUXXhjO257Nms9Sv1yJPNxOfPtTy8K4S6Tqq1M77XGPJ596scckMtYAwB852vTkWumsstNCueWb6sPxMxXxn3AuTVfvfmiU%2BuR1QYfi08aJKa83Z%2BYDLLnXGLL2dTl21m60xbw%2BQEKHICQLCgCIj7WKKWz%2FAwlmLy684FJd9bDz2aLVuS3fC%2FtWLfjgdEQ9eIgjIBiQVP6oM%2B3y07ImJqn8oWh5Jh6wPX%2FTj6otkNSZWqG0kCwkCBEA%2BoKhgM1DZRK%2Fmt6YWvHzhcgfDlGzem6Vf8fFNbeLxKgVqo6xlbu8OiOpuHSncmq9zYcK925%2BXTR9BmWqVtf20c6IUCyzt5cIK6Qq%2FmgB5mVLTydqamc6E%2BzYOW1%2Bd94PJpsyNxHOXUQyo%2FFK9XvapKCAdODh6qTsao5pnliQ5TKJMXCPqU%2F0pgybFOzgyx%2FgYgwZvfI3tBwivo5SSFVpB4B8bMesjVAsyxPuewQYWtrh5ZdWmIGQs8%2B1G03JWoSiT97GGq6n9gupegoL27xDexHCFIKdUo17iyIs0R9hWQUEJQUY0SjTJH%2F0x8ZEjxGPEw%2FaVSuQhWd9PLjxHsIPyDGmd7pWEK1S%2BSVAAQUSW0cuohGQpIsp10mXOj7IwyVDKaoe1YdZCFl4nTr%2FIq8%2Fx3tT1EmLazQ36pbvZNM5YQr6H1hDD9yEDIE0pVQlS79jctTdpONYLHUoQVsgykoJWSIpKh61TlGrEuxYpL%2FvndMydKT%2BtRvZa9vZwxY6RXc4AgPMAwCCmcYnfbxzzdR2iCvVr%2FUcauTdtE2cAgIC4xc5tBIvPenfvohfTuocX1316JLerXHasVve90et9NKhQpBRVqk8RncAIUlbGbV%2BsO520%2FKDZ8LuXFv660%2FMnYehwnDpbhGoAAEnmsuGqL8TLSy6pDZMH%2FictkTQdLzcYrLoiWicaJgvI%2BoR7cRVCDJG95eb8BHHNQzPj1MY92Pm5D2Xs6XftKVDkxGXiGnlOnhBuNRNv3u6%2Fl05L8rrHxmvuyBN3lyKimkeee5l0jCBkKuKVxzn8OtWYVoc7PuzIe66h1XfP8IKji3M%2BGEdmssgbjc1eDwrDUUWQ9l1szbsuDO3JE6KyY0F7nlOH7BqP%2FCzpG89LJGt%2BVrvS%2FnSa7gVmOpSmeOoJ5kYYnmRhlf1T7Oj504Vlf1muokzQ83R%2F0vt23kgZ8NYrDE74zsiI%2B4fqvPC2a%2BJkQD7leKVqYv0tz8a8t1xzw9wF%2B6oTXhuKqK7R3cy7tpFMsulaSigWOPiMv5q82imLDtT6nhjEHm0lhAAJo6sqzZLfGBTUQ6f2rjsU9k5TW2DhJFnXV7MYIcMtXxmbZ%2FIseY0iYKzKf%2F2QH38DCCL6GaUZjy%2BPubcbeXRsiuYiZ%2F8PyzhNOXNHHtkSRAxantyWEWYvMXqU8SNMJf6tnHuyh1rFzdlRj6ydYnlg2%2BJ5cVyisoFzT9E7zmKTuExcod6j%2BBbrSzQmSAI8y9x%2Fsrrss6UhxilOXfCV76XEWz4BKDBE6YS%2FWDjm%2FWmOUZ%2FMpn1sva8crFnJx93SSryaphRtDq8zUyJ6gasOsDTPW%2Fewa5uP9BbdMF%2FySPudPiuyP1%2FjdOILG97p2BUNgqIAABaPc%2FJpH53a4btFSjHwcrXk%2B1nVl%2FQVS3Wb0oNWZm7kVJXNJyl3WDuIOvWbfKeouL8Y0AspBeQ5%2FVnPhzv82pW3A9GDd5HNk80TNknOUCx4PR6zp6i4shPaH%2F2rJzqRp4JLfWLHiLlNkYOrMe2IxhKlGo07ya9xIFzz0ELLA6UJt49Edvfa9tTKzm3d4capfXphDYjX3wQgz6gOMb2Tsy0%2FD4Z8cGrcZP8Os%2B0VU8MDzi14OBzy8XLX6Y19s0lDqyiUiznjeeFAlLPa8P1Ok32hL3fKDlTLvlaettJbwxxCguIIACBAyHJLY%2Fltp6KS8dpGryUr9vVbxDXygiKnFJKFFMj6BCiV6VQ8kHf93cbcvyzGfnvzuOsnh72oC0BQFAAAQHaexZdsTIY80e%2B5pjrsm0Hk0W7b3WHhtohLstyGIFbNGASslAKv5plyNnBzuc4gZSLyxeeP%2B%2FNzLYZKAARFAQAA9M%2FReYOhCqsVyrvonaNzjlpB7wphccpEc9HQxlBvap%2BlXl%2BaLpBMu6856%2Bag7LGdS%2F73G7P8ZJGpCgD%2FD%2Ffbv1cjCgq6AAAAAElFTkSuQmCC"></a>
  <a href="http://daisy.ece.ucdavis.edu:8080/job/gunrock/job/master/"><img src="http://daisy.ece.ucdavis.edu:8080/buildStatus/icon?job=gunrock/master" alt="Build Status"></a>
  <br>
  <a href="https://github.com/gunrock/gunrock/blob/master/LICENSE.TXT"><img src="https://img.shields.io/github/license/gunrock/gunrock.svg" alt="Apache 2"></a>
  <a href="https://github.com/gunrock/gunrock/issues"><img src="https://img.shields.io/github/issues/gunrock/gunrock.svg" alt="Issues Open"></a>
  <a href="https://codecov.io/gh/gunrock/gunrock"><img src="https://codecov.io/gh/gunrock/gunrock/branch/master/graph/badge.svg" /></a>
  <br>
  <a href="https://developer.nvidia.com/gpu-accelerated-libraries"><img src="https://img.shields.io/badge/nvidia-accelerated%20library-green.svg?logo=nvidia" alt="NVIDIA Accelerated Libraries"></a>
  <a href="https://rapids.ai/community.html"><img src="https://img.shields.io/badge/rapids-contributor-%237400ff.svg" alt="RAPIDS"></a>
</p>

<h1 id="gunrock-gpu-graph-analytics" align="center">Gunrock: GPU Graph Analytics</h1>

<!-- end: gunrock's header -->

<p><strong>Gunrock</strong> is a CUDA library for graph-processing designed specifically for the GPU. It uses a <strong>high-level</strong>, <strong>bulk-synchronous</strong>, <strong>data-centric abstraction</strong> focused on operations on a vertex or edge frontier. Gunrock achieves a balance between performance and expressiveness by coupling high performance GPU computing primitives and optimization strategies with a high-level programming model that allows programmers to quickly develop new graph primitives with small code size and minimal GPU programming knowledge. For more details, see <a href="http://gunrock.github.io/docs/#overview">Gunrock's Overview</a>.</p>

<table style="font-size: 12px;"><thead>
<tr>
<th><strong>Service</strong></th>
<th><strong>System</strong></th>
<th><strong>Environment</strong></th>
<th><strong>Status</strong></th>
</tr>
</thead><tbody>
<tr>
<td><a href="https://jenkins.io/">Jenkins</a></td>
<td>Ubuntu 18.04.2 LTS</td>
<td>CUDA 10.1, NVIDIA Driver 418.39, GCC/G++ 7.3</td>
<td><a href="http://daisy.ece.ucdavis.edu:8080/blue/organizations/jenkins/gunrock/activity"><img src="http://daisy.ece.ucdavis.edu:8080/buildStatus/icon?job=gunrock/master" alt="Build Status"></a></td>
</tr>
</tbody></table>
<h2 id='quick-start-guide'>Quick Start Guide</h2>
<p>Before building Gunrock make sure you have <strong>CUDA 7.5 or higher</strong> (recommended CUDA 9 or higher) installed on your Linux system. We also support building Gunrock on docker images using the provided docker files under <code>docker</code> subdirectory. For complete build guide, see <a href="https://gunrock.github.io/docs/#building-gunrock">Building Gunrock</a>.</p>
<pre class="highlight mid-column-code shell tab-shell"><code>git clone --recursive https://github.com/gunrock/gunrock/
<span class="nb">cd </span>gunrock
mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake .. <span class="o">&amp;&amp;</span> make -j<span class="k">$(</span>nproc<span class="k">)</span>
make <span class="nb">test</span>
</code></pre><h2 id='getting-started-with-gunrock'>Getting Started with Gunrock</h2>
<ul>
<li>To learn more about Gunrock and its programming model, see <a href="http://gunrock.github.io/docs/#overview">Gunrock's Overview</a>.</li>
<li>For information on building Gunrock, see <a href="http://gunrock.github.io/docs/#building-gunrock">Building Gunrock</a>.</li>
<li>Tutorial: <a href="https://gunrock.github.io/docs/developers.html">How to write a graph primitive within Gunrock?</a></li>
<li>Comprehensive <a href="https://gunrock.github.io/docs/#gunrock-39-s-application-cases">list</a> of test applications and primitives for most the functionality of Gunrock.</li>
<li><a href="http://gunrock.github.io/gunrock">API Reference documentation</a> (generated using doxygen).</li>
<li>Find our <a href="http://gunrock.github.io/docs/#publications">publications</a>, <a href="http://gunrock.github.io/docs/#presentations">presentations</a>, and <a href="http://gunrock.github.io/docs/#results-and-analysis">results and analysis</a>.</li>
</ul>
<h2 id='copyright-and-license'>Copyright and License</h2>
<p>Gunrock is copyright The Regents of the University of California, 2013&ndash;2019. The library, examples, and all source code are released under <a href="https://github.com/gunrock/gunrock/blob/master/LICENSE.TXT">Apache 2.0</a>.</p>
<h1 id='overview'>Overview</h1><h2 id='what-is-gunrock'>What is <em>Gunrock</em>?</h2>
<p>Gunrock is a stable, powerful, and forward-looking substrate for GPU-based graph-centric research and development. Like many graph frameworks, it leverages a bulk-synchronous programming model and targets iterative convergent graph computations. We believe that today Gunrock offers both the <a href="#results-and-analysis">best performance on GPU graph analytics</a> as well as the <a href="#gunrock-39-s-application-cases">widest range of primitives</a>.</p>
<h2 id='who-may-use-gunrock'>Who may use <em>Gunrock</em>?</h2>
<ul>
<li><p><strong>External Interface Users:</strong> Users interested in leveraging the external C, C++ and/or Python interfaces to call <a href="#gunrock-39-s-application-cases">high-performance applications and primitives</a> (such as breadth-first search, connected components, PageRank, single-source shortest path, etc.) within Gunrock to perform graph analytics.</p></li>
<li><p><strong>Application Developers:</strong> Uses interested in developing applications, primitives, and/or low-level operators for Gunrock.</p></li>
<li><p><strong>Graph Analytics Library Developers:</strong> Gunrock can potentially serve as a back end for higher-level abstractions (e.g., DSLs for graph analytics, such as <a href="https://graphit-lang.org/">GraphIt</a> or a front end for lower-level abstractions (e.g., Gunrock's frontier model could potentially target a <a href="http://graphblas.org/">GraphBLAS</a> back end).</p></li>
</ul>
<h2 id='why-use-gunrock'>Why use <em>Gunrock</em>?</h2>
<ul>
<li><p><strong>Gunrock has the best performance of any programmable GPU+graph library.</strong> Gunrock primitives are an order of magnitude faster than (CPU-based) Boost, outperform any other programmable GPU-based system, and are comparable in performance to hardwired GPU graph primitive implementations. When compared to <a href="https://github.com/jshun/ligra">Ligra</a>, a best-of-breed CPU system, Gunrock currently matches or exceeds Ligra's 2-CPU performance with only one GPU.</p>

<p>Gunrock's abstraction separates its programming model from the low-level implementation details required to make a GPU implementation run fast. Most importantly, Gunrock features powerful load-balancing capabilities that effectively address the inherent irregularity in graphs, which is a problem we must address in all graph analytics. We have spent significant effort developing and optimizing these features---when we beat hardwired analytics, the reason is load balancing---and because they are beneath the level of the programming model, improving them makes all graph analytics run faster without needing to expose them to programmers.</p></li>
<li><p><strong>Gunrock's data-centric programming model is targeted at GPUs and offers advantages over other programming models.</strong> Gunrock is written in a higher-level abstraction than hardwired implementations, leveraging reuse of its fundamental operations across different graph primitives. Gunrock has a bulk-synchronous programming model that operates on a frontier of vertices or edges; unlike other GPU-based graph analytic programming models, Gunrock focuses not on sequencing <em>computation</em> but instead on sequencing <em><a href="#operators">operations</a> on frontier data structures</em>. This model has two main operations: <em>compute</em>, which performs a computation on every element in the current frontier, and <em>traversal</em>, which generates a new frontier from the current frontier. Traversal operations include <em>advance</em> (the new frontier is based on the neighbors of the current frontier) and <em>filter</em> (the new frontier is a programmable subset of the current frontier). Gunrock also currently offers segmented-intersection and neighbor-reduce operators.</p>

<p>This programming model is a better fit to high-performance GPU implementations than traditional programming models adapted from CPUs. Specifically, traditional models like gather-apply-scatter (GAS) map to a suboptimal set of GPU kernels that do a poor job of capturing producer-consumer locality. With Gunrock, we can easily integrate compute steps within the same kernels as traversal steps. As well, Gunrock's frontier-centric programming model is a better match for key optimizations such as push-pull direction-optimal search or priority queues, which have been a challenge to integrate into other GPU frameworks.</p></li>
<li><p><strong>Gunrock supports more primitives than any other programmable GPU+graph library.</strong> We currently support a wide variety of graph primitives, including traversal-based (breadth-first search, single-source shortest path); node-ranking (HITS, SALSA, PageRank); and global (connected component, minimum spanning tree). Many more algorithms are supported with others under active development; see <a href="https://gunrock.github.io/docs/#gunrock-39-s-application-cases">Gunrock Applications</a>.</p></li>
<li><p><strong>Gunrock's programming model scales to multiple GPUs with high performance while still using the same code as a single-GPU primitive.</strong> Other frameworks require rewriting their primitives when moving from one to many GPUs. Gunrock's multi-GPU programming model uses single-node Gunrock code at its core so that single-GPU and multi-GPU operations can share the same codebase, and Gunrock's single- and multi-GPU performance is best-in-class.</p></li>
</ul>
<h2 id='what-does-gunrock-not-do'>What does Gunrock not do?</h2>
<ul>
<li><p>Gunrock does not currently scale to multiple nodes ("scale-out"). Gunrock also does not scale to datasets that cannot fit into GPU memory ("scale-up"), for instance, datasets primarily stored in a larger CPU memory that may or may not require CPU-GPU coprocessing. Both of these problems are interesting to solve.</p></li>
<li><p>Gunrock is written in a bulk-synchronous programming model and does not currently have asynchronous capabilities.</p></li>
<li><p>Gunrock currently supports only static graph datasets; supporting dynamic graphs is an active area of current work.</p></li>
<li><p>For any given application, Gunrock's default parameters run the simplest possible Gunrock configurations and should not be used for performance comparisons. We have done no tuning of Gunrock's default parameters for performance.</p></li>
<li><p>Gunrock does no preprocessing on its datasets. Other projects have demonstrated that preprocessing datasets can deliver performance improvements. We believe this would also extend to Gunrock, but philosophically, we expect that the primary use case for Gunrock will be in pipelines of multiple stages where each stage receives an input from a previous stage, performs a computation on it, and outputs a result to the next stage. In this scenario, the previous stage's output is dynamically generated at runtime and thus not available for preprocessing. We hope that any graph libraries that do preprocessing report results with both preprocessed and unmodified input datasets.</p></li>
</ul>
<h1 id='programming-model'>Programming Model</h1>
<p>This page describes the programming model we use in Gunrock.</p>

<p>Gunrock targets graph computations that are generally expressed as "iterative convergent processes". By "iterative," we mean operations that may require running a series of steps repeatedly; by "convergent," we mean that these iterations allow us to approach the correct answer and terminate when that answer is reached. Many graph-computation programming models target a similar goal.</p>

<p>Many of these programming models focus on sequencing steps of <em>computation</em>.  Gunrock differs from these programming models in its focus on <em>manipulating a data structure</em>. We call this data structure a <em>frontier</em> of vertices or edges. <strong>The frontier represents the subset of vertices or edges that is actively participating in the computation.</strong> Gunrock operators input one or more frontiers and output one or more frontiers.</p>

<p>Generically, graph operations can often be expressed via a <em>push</em> abstraction (graph elements "push" local private updates into a shared state) or a <em>pull</em> abstraction (graph elements "pull" updates into their local private state) (<a href="https://htor.inf.ethz.ch/publications/index.php?pub=281">Besta et al. publication on push-vs.-pull, HPDC '17</a>). Gunrock's programming model supports both of these abstractions. (For instance, Gunrock's direction-optimized Breadth-First Search (BFS) and PageRank (PR) supports both push and pull BFS phases. <a href="https://github.com/gunrock/mini">Mini-Gunrock</a> supports pull-based BFS and PR.) Push-based approaches may or may not require synchronization (such as atomics) for correct operation; this depends on the primitive. Gunrock's idempotence optimization (within its BFS implementation) is an example of a push-based primitive that does not require atomics.</p>
<h2 id='operators'>Operators</h2>
<p>In the current Gunrock release, we support <strong>five</strong> operators.</p>

<ul>
<li><strong>Advance</strong>: An <em>advance</em> operator generates a new frontier from the current frontier by visiting the neighbors of the current frontier. A frontier can consist of either vertices or edges, and an advance step can input and output either kind of frontier. Advance is an irregularly-parallel operation for  two reasons: 1)~different vertices in a graph have different numbers of neighbors and 2)~vertices share neighbors. Thus a vertex in an input frontier map to multiple output items. An efficient advance is the most significant challenge of a GPU implementation.</li>
</ul>

<p><img src="images/advance.png" alt="Advance" /></p>

<ul>
<li><strong>Filter</strong>:  A <em>filter</em> operator generates a new frontier from the current frontier by choosing a subset of the current frontier based on programmer-specified criteria. Each input item maps to zero or one output items.</li>
</ul>

<p><img src="images/filter.png" alt="Filter" />  </p>

<ul>
<li><strong>Compute</strong>: A <em>compute</em> operator defines an operation on all elements (vertices or edges) in its input frontier. Gunrock implements a compute operator using <code>ForAll()</code> and <code>ForEach()</code> parallel loops. However, a programmer-specified operation can also be implemented using C++ lambda functions within the traversal operators such as advance or filter. Gunrock performs these operation in parallel across all elements without regard to order.</li>
</ul>

<p><img src="images/compute.png" alt="Compute" /></p>

<ul>
<li><p><strong>Segmented intersection</strong>: A <em>segmented intersection</em> operator takes two input node frontiers with the same length, or an input edge frontier, and generates both the number of total intersections and the intersected node IDs as the new frontier.</p></li>
<li><p><strong>Neighbor-Reduce</strong>: A <em>neighbor-reduce</em> operator uses the advance operator to visit the neighbor list of each item in the input frontier and performs a segmented reduction over the neighborhood (neighbor list) generated via the advance.</p></li>
</ul>
<h1 id='gunrock-39-s-application-cases'>Gunrock's Application Cases</h1>
<p>The following is are a wide variety of graph primitives, including traversal-based (breadth-first search, single-source shortest path); node-ranking (HITS, SALSA, PageRank); and global (connected component, minimum spanning tree) implemented within Gunrock.</p>

<p>The "Directory" column in the table below shows, which subdirectory within <code>gunrock/app</code> and <code>examples</code> these applications' implementations are. The version number in the "Single GPU" and "Multi-GPU" columns show which API abstraction of gunrock supports the respective application. If you are interested in helping us port an application in the older abstraction (<code>v0.5.x</code>) to a newer, much cleaner abstraction (<code>v1.x.x</code>), please see our <a href="https://gunrock.github.io/docs/developers.html#porting_guide">Porting Guide</a>.</p>

<table style="font-size: 12px;"><thead>
<tr>
<th>Application</th>
<th>Directory</th>
<th>Single GPU</th>
<th>Multi-GPU</th>
</tr>
</thead><tbody>
<tr>
<td>A* Search</td>
<td>astar</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>Betweenness Centrality</td>
<td>bc</td>
<td>v1.x.x</td>
<td>v0.5.x</td>
</tr>
<tr>
<td>Breadth-First Search</td>
<td>bfs</td>
<td>v1.x.x</td>
<td>v1.x.x</td>
</tr>
<tr>
<td>Connected Components</td>
<td>cc</td>
<td>v1.x.x</td>
<td>v0.5.x</td>
</tr>
<tr>
<td>Graph Coloring</td>
<td>color</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Geolocation</td>
<td>geo</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>RMAT Graph Generator</td>
<td>grmat</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>Graph Trend Filtering</td>
<td>gtf</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Hyperlink-Induced Topic Search</td>
<td>hits</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>K-Nearest Neighbors</td>
<td>knn</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Louvain Modularity</td>
<td>louvain</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Label Propagation</td>
<td>lp</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>MaxFlow</td>
<td>mf</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Minimum Spanning Tree</td>
<td>mst</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>PageRank</td>
<td>pr</td>
<td>v1.x.x</td>
<td>v0.5.x</td>
</tr>
<tr>
<td>Local Graph Clustering</td>
<td>pr_nibble</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Graph Projections</td>
<td>proj</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Random Walk</td>
<td>rw</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>GraphSAGE</td>
<td>sage</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Stochastic Approach for Link-Structure Analysis</td>
<td>salsa</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>Subgraph Matching</td>
<td>sm</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Shared Nearest Neighbors</td>
<td>snn</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Scan Statistics</td>
<td>ss</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Single Source Shortest Path</td>
<td>sssp</td>
<td>v1.x.x</td>
<td>v0.5.x</td>
</tr>
<tr>
<td>Triangle Counting</td>
<td>tc</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Top K</td>
<td>topk</td>
<td>v0.5.x</td>
<td></td>
</tr>
<tr>
<td>Vertex Nomination</td>
<td>vn</td>
<td>v1.x.x</td>
<td></td>
</tr>
<tr>
<td>Who To Follow</td>
<td>wtf</td>
<td>v0.5.x</td>
<td></td>
</tr>
</tbody></table>
<h1 id='building-gunrock'>Building Gunrock</h1>
<p>Gunrock's current release has been tested on Ubuntu 16.04 and 18.04 with CUDA 9+, compute architecture 3.0+ and g++ 4.8+. We expect Gunrock to build and run correctly on other 64-bit and 32-bit Linux distributions, and Mac OSX. We have an active issue investigating problems related to building Gunrock on <a href="https://github.com/gunrock/gunrock/issues/213">Windows</a>.</p>
<h2 id='installation'>Installation</h2>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#hardware">Hardware</a></li>
</ul>
<h2 id='prerequisites'>Prerequisites</h2>
<p><strong>Required Dependencies:</strong></p>

<ul>
<li><p>GCC &amp; G++</p></li>
<li><p><a href="https://developer.nvidia.com/cuda-zone">CUDA</a> (7.5 or higher) is used to implement Gunrock. Recommended CUDA version is CUDA 9 or higher, with some features such as Cooperative Groups and CUDA graphs only available in CUDA 10 or higher.</p>

<ul>
<li>Refer to NVIDIA's <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a> homepage to download and install CUDA.</li>
<li>Refer to NVIDIA <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C Programming Guide</a> for detailed information and examples on programming CUDA.</li>
</ul></li>
<li><p><a href="https://github.com/moderngpu/moderngpu">ModernGPU</a>, <a href="http://nvlabs.github.io/cub/">CUB</a> and RapidJSON used as external submodules for Gunrock's APIs.</p>

<ul>
<li>You will need to download or clone ModernGPU, CUB and RapidJSON, and place them to <code>gunrock/externals</code></li>
<li>Alternatively, you can clone gunrock recursively with <code>git clone --recursive https://github.com/gunrock/gunrock</code></li>
<li>or if you already cloned gunrock, under <code>gunrock/</code> directory: run <code>git submodule init</code> and
<code>git submodule update</code></li>
</ul></li>
</ul>

<p><strong>Optional Dependencies:</strong></p>

<ul>
<li><p>lcov</p></li>
<li><p>googletest</p></li>
<li><p><a href="http://www.boost.org/users/history/version_1_58_0.html">Boost</a> (version 1.58) is used for for the CPU reference implementations of Connected Component, Betweenness Centrality, PageRank, Single-Source Shortest Path, and Minimum Spanning Tree.</p>

<ul>
<li>Refer to Boost <a href="http://www.boost.org/doc/libs/1_58_0/more/getting_started/unix-variants.html">Getting Started Guide</a> to install the required Boost libraries.</li>
</ul></li>
<li><p><a href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview">METIS</a> is used as one possible partitioner to partition graphs for multi-gpu primitives implementations.</p>

<ul>
<li>Refer to METIS <a href="http://glaros.dtc.umn.edu/gkhome/metis/metis/download">Installation Guide</a>. If the build cannot find your METIS library, please set the <code>METIS_DLL</code> environment variable to the full path of the library.</li>
</ul></li>
<li><p>doxygen</p></li>
</ul>
<h2 id='compilation'>Compilation</h2>
<p><strong>Simple Gunrock Compilation:</strong></p>

<p>Downloading gunrock</p>
<pre class="highlight mid-column-code shell tab-shell"><code><span class="c"># Using git (recursively) download gunrock</span>
git clone --recursive https://github.com/gunrock/gunrock
<span class="c"># Using wget to download gunrock</span>
wget --no-check-certificate https://github.com/gunrock/gunrock/archive/master.zip
</code></pre>
<p>Compiling gunrock</p>
<pre class="highlight mid-column-code shell tab-shell"><code><span class="nb">cd </span>gunrock
mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake ..
make
</code></pre>
<ul>
<li>Binary test files are available in <code>build/bin</code> directory.</li>
<li>You can either run the test for all primitives by typing <code>make check</code> or <code>ctest</code> in the build directory, or do your own testings manually.</li>
<li>Detailed test log from <code>ctest</code> can be found in <code>/build/Testing/Temporary/LastTest.log</code>, alternatively you can run tests with verbose option enabled <code>ctest -v</code>.</li>
</ul>

<p><strong>Advance Gunrock Compilation:</strong></p>

<p>You can also compile gunrock with more specific/advanced settings using <code>cmake -D[OPTION]=ON/OFF</code>. Following options are available:</p>

<ul>
<li><strong>GUNROCK_BUILD_LIB</strong> (default: ON) - Builds main gunrock library.</li>
<li><strong>GUNROCK_BUILD_SHARED_LIBS</strong> (default: ON) - Turn off to build for static libraries.</li>
<li><strong>GUNROCK_BUILD_TESTS</strong> (default: ON) - Builds Gunrock applications and enables the <code>ctest</code> framework for single GPU implementations.</li>
<li><strong>GUNROCK_MGPU_TESTS</strong> (default: OFF) - If on, tests multiple GPU primitives with <code>ctest</code>.</li>
<li><strong>GUNROCK_GENCODE_SM<></strong> (default: GUNROCK_GENCODE_SM70=ON) change to generate code for a different compute capability.</li>
<li><strong>CUDA_VERBOSE_PTXAS</strong> (default: OFF) - ON to enable verbose output from the PTXAS assembler.</li>
<li><strong>GUNROCK_GOOGLE_TESTS</strong> (default: OFF) - ON to build unit tests using googletest.</li>
<li><strong>GUNROCK_CODE_COVERAGE</strong> (default: OFF) - ON to run code coverage on Gunrock's source code. Requires <code>lcov</code> to be installed on the system.</li>
<li><strong>GUNROCK_BUILD_APPLICATIONS</strong> (default: ON) - Set off to only build one of the following primitive (GUNROCK_APP_* must be set on to build if this option is turned off.) Example for compiling gunrock with only <em>Breadth First Search (BFS)</em> primitive, and list of some of the other applications that can be compiled using <code>cmake</code> (note: for the full list, see the <code>CMakeLists.txt</code> file).</li>
</ul>
<pre class="highlight mid-column-code shell tab-shell"><code>mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake -DGUNROCK_BUILD_APPLICATIONS<span class="o">=</span>OFF -DGUNROCK_APP_BFS<span class="o">=</span>ON ..
make
</code></pre>
<ul>
<li><strong>GUNROCK_APP_BC</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_BFS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_CC</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_PR</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_SSSP</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_DOBFS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_HITS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_SALSA</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_MST</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_WTF</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_TOPK</strong> (default: OFF)</li>
</ul>
<h2 id='generating-datasets'>Generating Datasets</h2>
<p>All dataset-related code is under the <code>dataset</code> subdirectory. The current version of Gunrock only supports <a href="http://math.nist.gov/MatrixMarket/formats.html">Matrix-market coordinate-formatted graph</a> format. The datasets are divided into two categories according to their scale. Under the <code>dataset/small/</code> subdirectory, there are trivial graph datasets for testing the correctness of the graph primitives. All of them are ready to use. Under the <code>dataset/large/</code> subdirectory, there are large graph datasets for doing performance regression tests.
* To download them to your local machine, just type <code>make</code> in the <code>dataset/large/</code> subdirectory.
* You can also choose to only download one specific dataset to your local machine by stepping into the subdirectory of that dataset and typing make inside that subdirectory.</p>
<h2 id='hardware'>Hardware</h2>
<p><strong>Laboratory Tested Hardware:</strong> Gunrock with GTX 970, Tesla K40s, GTX 1080, Tesla P100, RTX 2070, Tesla V100 and other NVIDIA cards. We have not encountered any trouble in-house with devices with CUDA capability >= 3.0.</p>
<h1 id='methodology'>Methodology</h1><h3 id='methodology-for-graph-analytics-performance'>Methodology for Graph Analytics Performance</h3>
<p>We welcome comments from others on the methodology that we use for measuring Gunrock's performance.</p>

<p>Currently, Gunrock is a library that requires no preprocessing. By this we mean that Gunrock inputs graphs in a "standard" format, e.g., compressed sparse row or coordinate, such as those available on common graph repositories (<a href="https://snap.stanford.edu/data/index.html">SNAP</a> or <a href="http://www.cise.ufl.edu/research/sparse/matrices/">SuiteSparse (UF)</a>). In our experiments, we use <a href="https://people.sc.fsu.edu/~jburkardt/data/mm/mm.html">MatrixMarket</a> format.</p>

<p>Other graph libraries may benefit from preprocessing of input datasets. We would regard any manipulation of the input dataset (e.g., reordering the input or more sophisticated preprocessing such as graph coloring or  <a href="http://farkhor.github.io/CuSha/">CuSha</a>'s G-Shards) to be preprocessing. We think preprocessing is an interesting future direction for Gunrock, but have not yet investigated it. We hope that any graph libraries that do preprocessing report results with both preprocessed and unmodified input datasets.</p>

<p>(That being said, we do standardize input graphs in two ways: before running our experiments, we remove self-loops/duplicated edges. If the undirected flag is set, we convert the input graph to undirected. When we do so, that implies one edge in each direction, and we report edges for that graph accordingly. What we do here appears to be standard practice.)</p>

<p>In general, we try to report results in two ways:</p>

<ul>
<li><strong>Throughput</strong>, measured in edges traversed per second (TEPS). We generally use millions of TEPS (MTEPS) as our figure of merit.</li>
<li><strong>Runtime</strong>, typically measured in ms. We measure runtime entirely on the GPU, with the expectation that the input data is already on the GPU and the output data will be stored on the GPU. This ignores transfer times (either disk to CPU or CPU to GPU), which are independent of the graph analytics system. It is our expectation that GPU graph analytics will be most effective when (a) they are run on complex primitives and/or (b) run on sequences of primitives, either of which would mitigate transfer times. GPU graph analytics are likely not well suited to running one single simple primitive; for a simple primitive like BFS, it is more expensive to transfer the graph from CPU to GPU than it is to complete the BFS.</li>
</ul>

<p>To calculate TEPS, we require the number of edges traversed (touched), which we count dynamically. For traversal primitives, we note that non-connected components will not be visited, so the number of visited edges may be fewer than the number of edges in the graph. We note that precisely counting edges during the execution of a particular primitive may have performance implications, so we may approximate (see BFS).</p>

<p>Notes on some of the Gunrock primitives follow.</p>
<h3 id='breadth-first-search-bfs'>Breadth-First Search (BFS)</h3>
<p>When we count the number of edges traversed, we do so by summing the number of outbound edges for each visited vertex. For forward, non-idempotent BFS, this strategy should give us an exact count, since this strategy visits every edge incident to a visited vertex. When we enable idempotence, we may visit a node more than once and hence may visit an edge more than once. For backward (pull) BFS, when we visit a vertex, we count all edges incoming to that vertex even if we find a visited predecessor before traversing all edges (and terminate early). (To do so otherwise has performance implications.) Enterprise uses the same counting strategy.</p>

<p>If a comparison library does not measure MTEPS for BFS, we compute it by the number of edges visited divided by runtime; if the former is not available, we use Gunrock's edges-visited count.</p>
<h3 id='single-source-shortest-path-sssp'>Single Source Shortest Path (SSSP)</h3>
<p>In general we find MTEPS comparisons between different approaches to SSSP not meaningful: because an edge may be visited one or many times, there is no standard way to count edges traversed. Different algorithms may not only visit a very different number of edges (Dijkstra vs. Bellman-Ford will have very different edge visit counts) but may also have a different number of edges visited across different invocations of the same primitive.</p>

<p>When we report Gunrock's SSSP MTEPS, we use the number of edges queued as the edge-traversal count.</p>

<p>To have a meaningful SSSP experiment, it is critical to have varying edge weights. SSSP measured on uniform edge weights is not meaningful (it becomes BFS). In our experiments, we set edge weights randomly/uniformly between 1 and 64.</p>
<h3 id='betweenness-centrality-bc'>Betweenness Centrality (BC)</h3>
<p>If a comparison library does not measure MTEPS for BC, we compute it by twice the number of edges visited in the forward phase divided by runtime (the same computation we use for Gunrock).</p>
<h3 id='pagerank-pr'>PageRank (PR)</h3>
<p>We measure PageRank elapsed time on one iteration of PageRank. (Many other engines measure results this way and it is difficult to extrapolate from this measurement to runtime of the entire algorithm.)</p>
<h1 id='results-and-analysis'>Results and Analysis</h1>
<p>We are gradually adding summaries of our results to these web pages (please let us know if you would like other comparisons). These summaries also include a table of results along with links to the configuration and results of each individual run. We detail our <a href="https://gunrock.github.io/docs/#methodology">methodology for our measurements here</a>.</p>

<ul>
<li><a href="https://gunrock.github.io/docs/engines_topc.html">Gunrock performance compared with other engines for graph analytics</a></li>
<li><a href="http://gunrock.github.io/gunrock/doc/latest/md_stats_do_ab_random.html">Setting parameters for direction-optimized BFS</a></li>
<li><a href="https://gunrock.github.io/docs/gunrock_gpus.html">Gunrock results on different GPUs</a></li>
<li><a href="https://gunrock.github.io/docs/frontier.html">Gunrock BFS throughput as a function of frontier size</a></li>
<li><a href="https://gunrock.github.io/docs/mgpu_speedup.html">Multi-GPU Gunrock Speedups</a> and <a href="https://gunrock.github.io/docs/mgpu_scalability.html">Multi-GPU Gunrock Scalability</a></li>
<li><a href="https://gunrock.github.io/docs/mgpu_partition.html">Multi-GPU Gunrock Partition Performance</a></li>
<li><a href="http://gunrock.github.io/docs/groute.html">Comparison to Groute</a></li>
</ul>

<p>For reproducibility, we maintain Gunrock configurations and results in our github <a href="https://github.com/gunrock/io/tree/master/gunrock-output">gunrock/io</a> repository.</p>

<p>We are happy to run experiments with other engines, particularly if those engines output results in our JSON format / a format that can be easily parsed into JSON format.</p>
<h1 id='publications'>Publications</h1>
<p>Muhammad Osama, Minh Truong, Carl Yang, Aydin Buluç and John D. Owens. <strong>Graph Coloring on the GPU</strong>. In Proceedings of the 33rd IEEE International Parallel and Distributed Processing Symposium Workshops, IPDPSW '19, pages 231&ndash;240, May 2019.
[<a href="#">DOI</a> |
<a href="#">http</a>]</p>

<p>Yuechao Pan, Roger Pearce, and John D. Owens. <strong>Scalable Breadth-First Search on a GPU Cluster</strong>. In Proceedings of the 31st IEEE International Parallel and Distributed Processing Symposium, IPDPS 2018, May 2018. [<a href="https://escholarship.org/uc/item/9bd842z6">http</a>]</p>

<p>Yangzihao Wang, Yuechao Pan, Andrew Davidson, Yuduo Wu, Carl Yang, Leyuan Wang, Muhammad Osama, Chenshan Yuan, Weitang Liu, Andy T. Riffel, and John D. Owens. <strong>Gunrock: GPU Graph Analytics</strong>. ACM Transactions on Parallel Computing, 4(1):3:1&ndash;3:49, August 2017. [<a href="http://dx.doi.org/10.1145/3108140">DOI</a> | <a href="http://escholarship.org/uc/item/9gj6r1dj">http</a>]</p>

<p>Yuechao Pan, Yangzihao Wang, Yuduo Wu, Carl Yang, and John D. Owens.
<strong>Multi-GPU Graph Analytics</strong>.  In Proceedings of the 31st IEEE International Parallel and Distributed Processing Symposium, IPDPS 2017, pages 479&ndash;490, May/June 2017.
[<a href="http://dx.doi.org/10.1109/IPDPS.2017.117">DOI</a> |
<a href="http://escholarship.org/uc/item/39r145g1">http</a>]</p>

<p>Yangzihao Wang, Sean Baxter, and John D. Owens. <strong>Mini-Gunrock: A Lightweight Graph Analytics Framework on the GPU</strong>. In Graph Algorithms Building Blocks, GABB 2017, pages 616&ndash;626, May 2017. [<a href="http://dx.doi.org/10.1109/IPDPSW.2017.116">DOI</a> | <a href="https://escholarship.org/uc/item/5wm061tr">http</a>]</p>

<p>Leyuan Wang, Yangzihao Wang, Carl Yang, and John D. Owens. <strong>A Comparative Study on Exact Triangle Counting Algorithms on the GPU</strong>. In Proceedings of the 1st High Performance Graph Processing Workshop, HPGP '16, pages 1&ndash;8, May 2016.
[<a href="http://dx.doi.org/10.1145/2915516.2915521">DOI</a> |
<a href="http://www.escholarship.org/uc/item/9hf0m6w3">http</a>]</p>

<p>Yangzihao Wang, Andrew Davidson, Yuechao Pan, Yuduo Wu, Andy Riffel, and John D. Owens.
<strong>Gunrock: A High-Performance Graph Processing Library on the GPU</strong>.
In Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, <a href="http://conf.researchr.org/home/ppopp-2016">PPoPP '16</a>, pages 11:1&ndash;11:12, March 2016. Distinguished Paper. [<a href="http://dx.doi.org/10.1145/2851141.2851145">DOI</a> | <a href="http://escholarship.org/uc/item/6xz7z9k0">http</a>]</p>

<p>Yuduo Wu, Yangzihao Wang, Yuechao Pan, Carl Yang, and John D. Owens.
<strong>Performance Characterization for High-Level Programming Models for GPU Graph
Analytics</strong>. In IEEE International Symposium on Workload Characterization,
IISWC-2015, pages 66&ndash;75, October 2015. Best Paper finalist. [<a href="http://dx.doi.org/10.1109/IISWC.2015.13">DOI</a> | <a href="http://escholarship.org/uc/item/2t69m5ht">http</a>]</p>

<p>Carl Yang, Yangzihao Wang, and John D. Owens.
<strong>Fast Sparse Matrix and Sparse Vector Multiplication Algorithm on the GPU</strong>.
In Graph Algorithms Building Blocks, GABB 2015, pages 841&ndash;847, May 2015.
[<a href="http://dx.doi.org/10.1109/IPDPSW.2015.77">DOI</a> | <a href="http://www.escholarship.org/uc/item/1rq9t3j3">http</a>]</p>

<p>Afton Geil, Yangzihao Wang, and John D. Owens.
<strong>WTF, GPU! Computing Twitter's Who-To-Follow on the GPU</strong>.
In Proceedings of the Second ACM Conference on Online Social Networks,
COSN '14, pages 63&ndash;68, October 2014.
[<a href="http://dx.doi.org/10.1145/2660460.2660481">DOI</a> | <a href="http://escholarship.org/uc/item/5xq3q8k0">http</a>]</p>
<h1 id='presentations'>Presentations</h1>
<p>GrAPL 2019, <strong>Graph Coloring on the GPU</strong>, May 2019. [<a href="#">slides</a>]</p>

<p>GTC 2018, <strong>Latest Development of the Gunrock Graph Processing Library on GPUs</strong>, March 2018. [<a href="http://on-demand.gputechconf.com/gtc/2018/presentation/s8594-latest-development-of-the-gunrock-graph-processing-library-on-gpus.pdf">slides</a> | <a href="http://on-demand.gputechconf.com/gtc/2018/video/S8594/">video</a>]</p>

<p>GTC 2018, <strong>Writing Graph Primitives with Gunrock</strong>, March 2018. [<a href="https://github.com/gunrock/docs/blob/master/source/pdf/Writing-Gunrock-Primitives.pdf">slides</a> | <a href="http://on-demand.gputechconf.com/gtc/2018/video/S8586/">video</a>]</p>

<p>GTC 2016, <strong>Gunrock: A Fast and Programmable Multi-GPU Graph Processing Library</strong>, April 2016. [<a href="http://on-demand.gputechconf.com/gtc/2016/presentation/s6374-yangzihao-wang-gunrock.pdf">slides</a>]</p>

<p>NVIDIA <a href="http://info.nvidianews.com/gunrock-webinar-reg-0416.html">webinar</a>, April 2016. [<a href="http://tinyurl.com/owens-nv-webinar-160426">slides</a>]</p>

<p>GPU Technology Theater at SC15, <strong>Gunrock: A Fast and Programmable Multi-GPU Graph processing Library</strong>, November 2015. [<a href="http://images.nvidia.com/events/sc15/pdfs/SC5139-gunrock-multi-gpu-processing-library.pdf">slides</a> | <a href="http://images.nvidia.com/events/sc15/SC5139-gunrock-multi-gpu-processing-library.html">video</a>]</p>

<p>GTC 2014, <strong>High-Performance Graph Primitives on the GPU: design and Implementation of Gunrock</strong>, March 2014. [<a href="http://on-demand.gputechconf.com/gtc/2014/presentations/S4609-hi-perf-graph-primitives-on-gpus.pdf">slides</a> | <a href="http://on-demand.gputechconf.com/gtc/2014/video/S4609-hi-perf-graph-primitives-on-gpus.mp4">video</a>]</p>
<h1 id='road-map'>Road Map</h1>
<p>We have three principal near-term priorities for Gunrock development (as of June 2019):</p>

<ul>
<li><p>Gunrock's 1.0 release focused on single-GPU performance. We expect to target single-node multi-GPU support in a near-term future release.</p></li>
<li><p>We believe dynamic (mutable) graphs are a practically interesting area of graph analytics that has not been a focus of the GPU graph analytics research community.</p></li>
<li><p>We will ensure that Gunrock will integrate with NVIDIA's <a href="https://rapids.ai/">RAPIDS</a> suite of software libraries to accelerate data science workloads on GPUs.</p></li>
</ul>

<p>We also continue to pursue projects in scalability (within a node, across nodes, and across the CPU-GPU boundary); in programmability, including working with the MIT <a href="http://graphit-lang.org/">GraphIt</a> team; in improving Gunrock's internals, both their performance and their modularity; in expanding the number and coverage of applications written in Gunrock; and in better interoperability with other tools, languages, and libraries.</p>
<h1 id='possible-gunrock-projects'>Possible Gunrock projects</h1>
<p>Possible projects are in two categories: infrastructure projects that make Gunrock better but have minimal research value, and research projects that are longer-term and hopefully have research implications of use to the community.</p>

<p>For any discussion on these, please use the existing Github issue (or make one).</p>
<h2 id='infrastructure-projects'>Infrastructure projects</h2>
<ul>
<li>Containerize Gunrock (a Docker container) [<a href="https://github.com/gunrock/gunrock/issues/349">issue</a>]</li>
<li>Support a Windows build [<a href="https://github.com/gunrock/gunrock/issues/213">issue</a>]</li>
<li>Develop a procedure to go from "How does Gunrock do on dataset X" to actually getting results and the right command lines for dataset X. Right now we do this manually with lots of iterations every time. We can automate and document this much better.</li>
<li>Many apps have minimal documentation; we need better text when a user runs <code>./bin/primitive --help</code>.</li>
</ul>
<h2 id='research-projects'>Research projects</h2>
<ul>
<li>Better defaults and/or decision procedures for setting Gunrock parameters (possibly a machine-learning approach for this)</li>
<li>How can we preprocess Gunrock input to increase performance? This could be either reordering CSR for better performance (e.g., reverse Cuthill-McKee) or a new format. Note <a href="https://ieeexplore.ieee.org/document/8573478">When is Graph Reordering an Optimization? Studying the Effect of Lightweight Graph Reordering Across Applications and Input Graphs</a>.</li>
<li>If we had a larger number of X in the hardware&mdash;e.g., more registers, more SMs, more threads/SM, more shared memory, bigger cache---how would it help performance? (Where would we want NVIDIA to spend more transistors to best help our performance?)</li>
<li>How much locality is there in frontiers with respect to the "active" frontier vs. the entire set of vertices? Interesting visualization project, for instance: Get a list of the active vertices in a frontier as a function of iteration, so iteration 0 is vertex set A, iteration 1 is vertex set B, etc. For one iteration, visualize the vertex set as a color per chunk of vertices, say, 1024 vertices per pixel. If all 1024 vertices are part of that frontier, the pixel is white, if 0 black, and gray in between. Then each iteration makes another row of pixels. This shows three things: (a) how many vertices are in the frontier compared to not; (b) how much spatial locality there is; (c) how the frontier evolves over time. One of the goals of this effort would be to determine how useful it would be to do some reordering of vertices either statically or dynamically, and either locally (within a chunk of vertices) or globally.</li>
</ul>
<h1 id='gunrock-developers'>Gunrock Developers</h1>
<ul>
<li><a href="http://www.idav.ucdavis.edu/~yzhwang/">Yangzihao Wang</a>,
University of California, Davis</li>
<li><a href="https://sites.google.com/site/panyuechao/home">Yuechao Pan</a>, University of California, Davis</li>
<li><a href="http://www.yuduowu.com/">Yuduo Wu</a>,
University of California, Davis</li>
<li><a href="http://web.ece.ucdavis.edu/~ctcyang/">Carl Yang</a>,
University of California, Davis</li>
<li><a href="http://www.ece.ucdavis.edu/~laurawly/">Leyuan Wang</a>,
University of California, Davis</li>
<li>Weitang Liu, University of California, Davis</li>
<li><a href="http://www.ece.ucdavis.edu/~mosama/">Muhammad Osama</a>,
University of California, Davis</li>
<li>Chenshan Shari Yuan, University of California, Davis</li>
<li>Andy Riffel, University of California, Davis</li>
<li><a href="http://www.huan-zhang.com/">Huan Zhang</a>,
University of California, Davis</li>
<li><a href="http://www.ece.ucdavis.edu/~jowens/">John Owens</a>,
University of California, Davis</li>
</ul>
<h1 id='frequently-asked-questions'>Frequently Asked Questions</h1>
<p>Some of the most common questions we have come across during the life of Gunrock project. If your question isn't already answered below, feel free to create an <a href="https://github.com/gunrock/gunrock/issues">issue</a> on GitHub.</p>
<h2 id='what-does-it-do'>What does it do?</h2>
<p>Gunrock is a fast and efficient graph processing library on the GPU that provides a set of graph algorithms used in big data analytics and visualization with high performance.  It also provides a set of operators which abstract the general operations in graph processing for other developers to build high-performance graph algorithm prototypes with minimum programming effort.</p>
<h2 id='how-does-it-do-it'>How does it do it?</h2>
<p>Gunrock takes advantage of the immense computational power available in commodity-level, off-the-shelf Graphics Processing Units (GPUs), originally designed to handle the parallel computational tasks in computer graphics, to perform graph traversal and computation in parallel on thousands of GPU's computing cores.</p>
<h2 id='who-should-want-this'>Who should want this?</h2>
<p>Gunrock is built with two kinds of users in mind: The first kind of users are programmers who build big graph analytics and visualization projects and need to use existing graph primitives provided by Gunrock.  The second kind of users are programmers who want to use Gunrock's high-level, programmable abstraction to express, develop, and refine their own (and often more complicated) graph primitives.</p>
<h2 id='when-would-gunrock-be-a-bad-choice'>When would Gunrock be a bad choice?</h2>
<p>If your graph is too <em>small</em>, it's a bad fit for Gunrock (and the GPU). For most workloads, a GPU isn't a good fit until the graph reaches at least a few thousand nodes. Conversely, if your graph is too <em>large</em> and doesn't fit into GPU memory (or, for single-node multi-GPU configurations, into the aggregate GPU memories of all GPUs on the node), it's also a bad fit for Gunrock. Finally, Gunrock also does not currently support multi-node (distributed) execution, although Gunrock would probably be a good single-node component of a future distributed graph framework. Both the out-of-core (scale-up) and multi-node (scale-out) problems are excellent research programs.</p>
<h2 id='what-is-the-skill-set-users-need-to-use-it'>What is the skill set users need to use it?</h2>
<p>For the first kind of users, C/C++ background is sufficient. We are also building Gunrock as a shared library with C interfaces that can be loaded by other languages such as Python and Julia.  For the second kind of users, they need to have the C/C++ background and also an understanding of parallel programming, especially BSP (Bulk-Synchronous Programming) model used by Gunrock.</p>
<h2 id='what-platforms-languages-do-people-need-to-know-in-order-to-modify-or-integrate-it-with-other-tools'>What platforms/languages do people need to know in order to modify or integrate it with other tools?</h2>
<p>Using the exposed interface, the users do not need to know CUDA to modify or integrate Gunrock to their own tools. However, an essential understanding of parallel programming and BSP model is necessary if one wants to add/modify graph primitives in Gunrock.</p>
<h2 id='why-would-someone-want-this'>Why would someone want this?</h2>
<p>The study of social networks, webgraphs, biological networks, and unstructured meshes in scientific simulation has raised a significant demand for efficient parallel frameworks for processing and analytics on large-scale graphs. Initial research efforts in using GPUs for graph processing and analytics are promising.</p>
<h2 id='how-is-it-better-than-the-current-state-of-the-art'>How is it better than the current state of the art?</h2>
<p>Gunrock delivers best-in-class performance at a low cost with a high-level, productive, flexible programming model that enables writing a <a href="#gunrock-39-s-application-cases">large number of graph applications</a>. GPUs are becoming ubiquitous not just on the desktop but also in the cloud; Gunrock is competitive with much larger and more expensive distributed graph frameworks at a much lower cost. It generally outperforms the best CPU frameworks across its application suite, and among GPU frameworks, enables both high performance and high productivity.</p>
<h2 id='how-would-someone-get-it'>How would someone get it?</h2>
<p>Gunrock is an open-source library. The code, documentation, and quick start guide are all on its <a href="gunrock.github.io">GitHub page</a>.</p>
<h2 id='is-a-user-account-required'>Is a user account required?</h2>
<p>No. One can use either git clone or download directly to get the source code and documentation of Gunrock.</p>
<h2 id='are-all-of-its-components-dependencies-easy-to-find'>Are all of its components/dependencies easy to find?</h2>
<p>Gunrock has two dependencies. Both of them are GPU primitive libraries which also reside on GitHub. All dependencies do not require installation. To use, one only needs to download or git clone them and put them in the according directories. More details in the installation section of this documentation.</p>
<h2 id='how-would-someone-install-it'>How would someone install it?</h2>
<p>For a C/C++ programmer, integrating Gunrock into your projects is easy. Since it is a template based library, just add the include files in your code. The simple example and all the testrigs will provide detailed information on how to do this.</p>

<p>For programmers who use Python, Julia, or other language and want to call Gunrock APIs, we are building a shared library with binary compatible C interfaces. It will be included in the soon-to-arrive next release of Gunrock.</p>
<h2 id='can-anyone-install-it-do-they-need-it-help'>Can anyone install it? Do they need IT help?</h2>
<p>Gunrock is targeted at developers who are familiar with basic software engineering. For non-technical people, IT help might be needed.</p>
<h2 id='does-this-process-actually-work-all-the-time-on-all-systems-specified'>Does this process actually work? All the time? On all systems specified?</h2>
<p>Currently, Gunrock has been tested on two Linux distributions: Linux Mint and Ubuntu. But we expect it to run correctly on other Linux distributions too. We expect a Mac build would work (it has in the past), but don't currently have a Mac+NVIDIA machine on which we can test. Windows is not currently supported (we welcome pull requests that would allow us to support Windows).</p>
<h2 id='how-would-someone-test-that-it-39-s-working-with-provided-sample-data'>How would someone test that it's working with provided sample data?</h2>
<p>Testrigs are provided as well as a small simple example for users to test the correctness and performance of every graph primitive.</p>
<h2 id='is-the-quot-using-quot-of-sample-data-clear'>Is the "using" of sample data clear?</h2>
<p>On Linux, one only needs to go to the dataset directory and run "make"; the script will automatically download all the needed datasets. One can also choose to download a single dataset in its separate directory.</p>
<h2 id='how-would-someone-use-it-with-their-own-data'>How would someone use it with their own data?</h2>
<p>Gunrock supports Matrix Market (.mtx) file format; users need to pre-process the graph data into this format before running Gunrock.</p>
<h1 id='release-notes'>Release Notes</h1>
<p>Please see our <a href="https://github.com/gunrock/gunrock/releases">release notes</a> and current releases.</p>
<h1 id='acknowledgments'>Acknowledgments</h1>
<p>Thanks to the following developers who contributed code: The connected-component implementation was derived from code written by Jyothish Soman, Kothapalli Kishore, and P. J. Narayanan and described in their IPDPSW '10 paper <em>A Fast GPU Algorithm for Graph Connectivity</em> (<a href="http://dx.doi.org/10.1109/IPDPSW.2010.5470817">DOI</a>). The breadth-first search implementation and many of the utility functions in Gunrock are derived from the <a href="http://code.google.com/p/back40computing/">b40c</a> library of <a href="https://sites.google.com/site/duanemerrill/">Duane Merrill</a>. The algorithm is described in his PPoPP '12 paper <em>Scalable GPU Graph Traversal</em> (<a href="http://dx.doi.org/10.1145/2370036.2145832">DOI</a>). Thanks to Erich Elsen and Vishal Vaidyanathan from <a href="http://www.royal-caliber.com/">Royal Caliber</a> and the <a href="http://www.onu.io/">Onu</a> Team for their discussion on library development and the dataset auto-generating code. Thanks to Adam McLaughlin for his technical discussion. Thanks to Oded Green for his technical discussion and an optimization in the CC primitive. Thanks to the <a href="https://altair-viz.github.io/">Altair</a> and <a href="https://vega.github.io/vega-lite/">Vega-lite</a> teams in the <a href="http://idl.cs.washington.edu/">Interactive Data Lab</a> at the University of Washington for graphing help. We appreciate the technical assistance, advice, and machine access from many colleagues at NVIDIA: Chandra Cheij, Joe Eaton, Michael Garland, Mark Harris, Ujval Kapasi, David Luebke, Duane Merrill, Josh Patterson, Nikolai Sakharnykh, and Cliff Woolley.</p>

<p>This work was funded by the DARPA HIVE program under AFRL Contract FA8650-18-2-7835, the DARPA XDATA program under AFRL Contract FA8750-13-C-0002, by NSF awards OAC-1740333, CCF-1629657, OCI-1032859, and CCF-1017399, by DARPA STTR award D14PC00023, and by DARPA SBIR award W911NF-16-C-0020. Our XDATA principal investigator was Eric Whyne of <a href="http://www.data-tactics.com/">Data Tactics Corporation</a> and our DARPA program manager is <a href="http://www.darpa.mil/staff/mr-wade-shen">Mr. Wade Shen</a> (since 2015), and before that Dr. Christopher White (2012&ndash;2014). Thanks to Chris, Wade, and DARPA business manager Gabriela Araujo for their support during the XDATA program.</p>

      </div>

        <!-- <div class="dark-box"></div> -->
    </div>
  </body>
</html>
