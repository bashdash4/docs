
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="icon" type="image/ico" href="images/favicon.ico">
    <title>Gunrock</title>

    <script type="text/javascript" src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@4"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <style media="screen">
      /* Add space between vega-embed links */
      /* http://vega.github.io/vega-tutorials/airports/ */
      .vega-embed .vega-actions a {
        margin-left: 1em;
        visibility: hidden;
      }
      .vega-embed:hover .vega-actions a {
        visibility: visible;
      }
    </style>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo.png" class="logo" alt="Logo" />
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc" class="toc-list-h1">
          <li>
            <a href="#gunrock-gpu-graph-analytics" class="toc-h1 toc-link" data-title="Gunrock: GPU Graph Analytics">GUNROCK: GPU GRAPH ANALYTICS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#quick-start-guide" class="toc-h2 toc-link" data-title="Quick Start Guide">Quick Start Guide</a>
                  </li>
                  <li>
                    <a href="#getting-started-with-gunrock" class="toc-h2 toc-link" data-title="Getting Started with Gunrock">Getting Started with Gunrock</a>
                  </li>
                  <li>
                    <a href="#copyright-and-license" class="toc-h2 toc-link" data-title="Copyright and License">Copyright and License</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#building-gunrock" class="toc-h1 toc-link" data-title="Building Gunrock">BUILDING GUNROCK</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#installation" class="toc-h2 toc-link" data-title="Installation">Installation</a>
                  </li>
                  <li>
                    <a href="#prerequisites" class="toc-h2 toc-link" data-title="Prerequisites">Prerequisites</a>
                  </li>
                  <li>
                    <a href="#compilation" class="toc-h2 toc-link" data-title="Compilation">Compilation</a>
                  </li>
                  <li>
                    <a href="#generating-datasets" class="toc-h2 toc-link" data-title="Generating Datasets">Generating Datasets</a>
                  </li>
                  <li>
                    <a href="#hardware" class="toc-h2 toc-link" data-title="Hardware">Hardware</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#why-gunrock" class="toc-h1 toc-link" data-title="Why Gunrock?">WHY GUNROCK?</a>
          </li>
          <li>
            <a href="#methodology-for-graph-analytics-performance" class="toc-h1 toc-link" data-title="Methodology for Graph Analytics Performance">METHODOLOGY FOR GRAPH ANALYTICS PERFORMANCE</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#bfs" class="toc-h2 toc-link" data-title="BFS">BFS</a>
                  </li>
                  <li>
                    <a href="#sssp" class="toc-h2 toc-link" data-title="SSSP">SSSP</a>
                  </li>
                  <li>
                    <a href="#bc" class="toc-h2 toc-link" data-title="BC">BC</a>
                  </li>
                  <li>
                    <a href="#pagerank" class="toc-h2 toc-link" data-title="PageRank">PageRank</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#programming-model" class="toc-h1 toc-link" data-title="Programming Model">PROGRAMMING MODEL</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#operators" class="toc-h2 toc-link" data-title="Operators">Operators</a>
                  </li>
                  <li>
                    <a href="#creating-a-new-graph-primitive" class="toc-h2 toc-link" data-title="Creating a New Graph Primitive">Creating a New Graph Primitive</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#git-forking-workflow" class="toc-h1 toc-link" data-title="Git Forking Workflow">GIT FORKING WORKFLOW</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#how-forking-workflow-works" class="toc-h2 toc-link" data-title="How Forking Workflow Works?">How Forking Workflow Works?</a>
                  </li>
                  <li>
                    <a href="#gunrock-39-s-forking-workflow" class="toc-h2 toc-link" data-title="Gunrock's Forking Workflow:">Gunrock's Forking Workflow:</a>
                  </li>
                  <li>
                    <a href="#how-to-contribute" class="toc-h2 toc-link" data-title="How to contribute?">How to contribute?</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#googletest-for-gunrock" class="toc-h1 toc-link" data-title="GoogleTest for Gunrock">GOOGLETEST FOR GUNROCK</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#example-test-using-googletest" class="toc-h2 toc-link" data-title="Example Test Using GoogleTest">Example Test Using GoogleTest</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#road-map" class="toc-h1 toc-link" data-title="Road Map">ROAD MAP</a>
          </li>
          <li>
            <a href="#possible-gunrock-projects" class="toc-h1 toc-link" data-title="Possible Gunrock projects">POSSIBLE GUNROCK PROJECTS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#infrastructure-projects" class="toc-h2 toc-link" data-title="Infrastructure projects">Infrastructure projects</a>
                  </li>
                  <li>
                    <a href="#research-projects" class="toc-h2 toc-link" data-title="Research projects">Research projects</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#gunrock-v0-5-release-notes" class="toc-h1 toc-link" data-title="Gunrock v0.5 Release Notes">GUNROCK V0.5 RELEASE NOTES</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#changelog" class="toc-h2 toc-link" data-title="ChangeLog">ChangeLog</a>
                  </li>
                  <li>
                    <a href="#known-issues" class="toc-h2 toc-link" data-title="Known Issues">Known Issues</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#frequently-asked-questions" class="toc-h1 toc-link" data-title="Frequently Asked Questions">FREQUENTLY ASKED QUESTIONS</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#what-does-it-do" class="toc-h2 toc-link" data-title="What does it do?">What does it do?</a>
                  </li>
                  <li>
                    <a href="#how-does-it-do-it" class="toc-h2 toc-link" data-title="How does it do it?">How does it do it?</a>
                  </li>
                  <li>
                    <a href="#who-should-want-this" class="toc-h2 toc-link" data-title="Who should want this?">Who should want this?</a>
                  </li>
                  <li>
                    <a href="#what-is-the-skill-set-users-need-to-use-it" class="toc-h2 toc-link" data-title="What is the skill set users need to use it?">What is the skill set users need to use it?</a>
                  </li>
                  <li>
                    <a href="#what-platforms-languages-do-people-need-to-know-in-order-to-modify-or-integrate-it-with-other-tools" class="toc-h2 toc-link" data-title="What platforms/languages do people need to know in order to modify or integrate it with other tools?">What platforms/languages do people need to know in order to modify or integrate it with other tools?</a>
                  </li>
                  <li>
                    <a href="#why-would-someone-want-this" class="toc-h2 toc-link" data-title="Why would someone want this?">Why would someone want this?</a>
                  </li>
                  <li>
                    <a href="#how-is-it-better-than-the-current-state-of-the-art" class="toc-h2 toc-link" data-title="How is it better than the current state of the art?">How is it better than the current state of the art?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-get-it" class="toc-h2 toc-link" data-title="How would someone get it?">How would someone get it?</a>
                  </li>
                  <li>
                    <a href="#is-a-user-account-required" class="toc-h2 toc-link" data-title="Is a user account required?">Is a user account required?</a>
                  </li>
                  <li>
                    <a href="#are-all-of-its-components-dependencies-easy-to-find" class="toc-h2 toc-link" data-title="Are all of its components/dependencies easy to find?">Are all of its components/dependencies easy to find?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-install-it" class="toc-h2 toc-link" data-title="How would someone install it?">How would someone install it?</a>
                  </li>
                  <li>
                    <a href="#can-anyone-install-it-do-they-need-it-help" class="toc-h2 toc-link" data-title="Can anyone install it? Do they need IT help?">Can anyone install it? Do they need IT help?</a>
                  </li>
                  <li>
                    <a href="#does-this-process-actually-work-all-the-time-on-all-systems-specified" class="toc-h2 toc-link" data-title="Does this process actually work? All the time? On all systems specified?">Does this process actually work? All the time? On all systems specified?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-test-that-it-39-s-working-with-provided-sample-data" class="toc-h2 toc-link" data-title="How would someone test that it's working with provided sample data?">How would someone test that it's working with provided sample data?</a>
                  </li>
                  <li>
                    <a href="#is-the-quot-using-quot-of-sample-data-clear" class="toc-h2 toc-link" data-title="Is the "using" of sample data clear?">Is the "using" of sample data clear?</a>
                  </li>
                  <li>
                    <a href="#how-would-someone-use-it-with-their-own-data" class="toc-h2 toc-link" data-title="How would someone use it with their own data?">How would someone use it with their own data?</a>
                  </li>
              </ul>
          </li>
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/gunrock/gunrock'>Gunrock; GPU Graph Analytics</a></li>
            <li>Gunrock © 2018 The Regents of the University of California.</li>
        </ul>
    </div>
    <div class="page-wrapper">

        <div class="dark-box"></div>

      <div class="content">
        <!-- start: gunrock's header -->

<p align="center">
  <a href="https://github.com/gunrock/gunrock/"><img src="https://github.com/gunrock/docs/raw/master/source/images/GunrockLogo150px.png"></a>
  <br>
  <a href="https://github.com/gunrock/gunrock/releases/tag/v1.0"><img src="https://img.shields.io/badge/gunrock-v1.0-blue.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAIjklEQVRIDQXBaZCeBWEA4Oc9vnN3v93sbrKbhGxCIMVASERQSCt0BCo4lOGonVirMOPR45cVbS3t1B8OYy%2B1WKdFtKPiqB162LHjdAZqKQUBwyEBYgKJuZYku9kju%2Fvtd79XnycoAHD0NznzEDe1OT1gOmDhLLMhN5RxLcEtrOxn%2BX6VbTOu6Z52oVh2auOHqf2CE%2BucmWXuFfbuo3w5UcpShWLAxhUuv5UQAAAAACDMSdus3EP4Hu%2BeHLG0dMgLSdfJZNID0SKQIisQAAAAADEAAAAEyDHIyAqCNp0%2FNDR8wTOdFZXpHT7U6rizvezLC4cllZJ%2FCiLdSkha0E%2BICiLkAQEAQgAAUJAVJDlRyoaGLc1Rn2w1fbd81FxnXXWy7%2FbGwOPdno%2BEQ462m%2F5%2BYUknWnNie8OXLt%2FttjgSV2OKgjAjKSgCIAYAAWnCANWQNGCo5g%2FKQx7pJ6Rt6mXCgG7f7k7hyaCqESY25jnlOmluZ8Rntl%2FiM3nuZNj0%2Bf7A9VM0VkJ%2FJnBeQFAA4Pg9nH%2FQ1u0XPRbGrhaaTbquKwrKAWEoa0f%2BNkztDsruynPz1dx00TZb2%2BKuYs1lacfvGfH%2BQU46ICqIQ0oRSSoNYu%2Fa9j5vhG7CTbiKiyM0Bn4UF24p2uJ01bVZxFBIJ%2Fd1I8ZfO%2BPB5pC7J%2Bv%2BJu6abrcdmeq4cXSTQ%2FWL%2Fn1r1W3ry3Z3VrxQKhPHfnluWHS8sLnZF8e5b%2FdfJfYQUmxgvO1TxUXXhjO257Nms9Sv1yJPNxOfPtTy8K4S6Tqq1M77XGPJ596scckMtYAwB852vTkWumsstNCueWb6sPxMxXxn3AuTVfvfmiU%2BuR1QYfi08aJKa83Z%2BYDLLnXGLL2dTl21m60xbw%2BQEKHICQLCgCIj7WKKWz%2FAwlmLy684FJd9bDz2aLVuS3fC%2FtWLfjgdEQ9eIgjIBiQVP6oM%2B3y07ImJqn8oWh5Jh6wPX%2FTj6otkNSZWqG0kCwkCBEA%2BoKhgM1DZRK%2Fmt6YWvHzhcgfDlGzem6Vf8fFNbeLxKgVqo6xlbu8OiOpuHSncmq9zYcK925%2BXTR9BmWqVtf20c6IUCyzt5cIK6Qq%2FmgB5mVLTydqamc6E%2BzYOW1%2Bd94PJpsyNxHOXUQyo%2FFK9XvapKCAdODh6qTsao5pnliQ5TKJMXCPqU%2F0pgybFOzgyx%2FgYgwZvfI3tBwivo5SSFVpB4B8bMesjVAsyxPuewQYWtrh5ZdWmIGQs8%2B1G03JWoSiT97GGq6n9gupegoL27xDexHCFIKdUo17iyIs0R9hWQUEJQUY0SjTJH%2F0x8ZEjxGPEw%2FaVSuQhWd9PLjxHsIPyDGmd7pWEK1S%2BSVAAQUSW0cuohGQpIsp10mXOj7IwyVDKaoe1YdZCFl4nTr%2FIq8%2Fx3tT1EmLazQ36pbvZNM5YQr6H1hDD9yEDIE0pVQlS79jctTdpONYLHUoQVsgykoJWSIpKh61TlGrEuxYpL%2FvndMydKT%2BtRvZa9vZwxY6RXc4AgPMAwCCmcYnfbxzzdR2iCvVr%2FUcauTdtE2cAgIC4xc5tBIvPenfvohfTuocX1316JLerXHasVve90et9NKhQpBRVqk8RncAIUlbGbV%2BsO520%2FKDZ8LuXFv660%2FMnYehwnDpbhGoAAEnmsuGqL8TLSy6pDZMH%2FictkTQdLzcYrLoiWicaJgvI%2BoR7cRVCDJG95eb8BHHNQzPj1MY92Pm5D2Xs6XftKVDkxGXiGnlOnhBuNRNv3u6%2Fl05L8rrHxmvuyBN3lyKimkeee5l0jCBkKuKVxzn8OtWYVoc7PuzIe66h1XfP8IKji3M%2BGEdmssgbjc1eDwrDUUWQ9l1szbsuDO3JE6KyY0F7nlOH7BqP%2FCzpG89LJGt%2BVrvS%2FnSa7gVmOpSmeOoJ5kYYnmRhlf1T7Oj504Vlf1muokzQ83R%2F0vt23kgZ8NYrDE74zsiI%2B4fqvPC2a%2BJkQD7leKVqYv0tz8a8t1xzw9wF%2B6oTXhuKqK7R3cy7tpFMsulaSigWOPiMv5q82imLDtT6nhjEHm0lhAAJo6sqzZLfGBTUQ6f2rjsU9k5TW2DhJFnXV7MYIcMtXxmbZ%2FIseY0iYKzKf%2F2QH38DCCL6GaUZjy%2BPubcbeXRsiuYiZ%2F8PyzhNOXNHHtkSRAxantyWEWYvMXqU8SNMJf6tnHuyh1rFzdlRj6ydYnlg2%2BJ5cVyisoFzT9E7zmKTuExcod6j%2BBbrSzQmSAI8y9x%2Fsrrss6UhxilOXfCV76XEWz4BKDBE6YS%2FWDjm%2FWmOUZ%2FMpn1sva8crFnJx93SSryaphRtDq8zUyJ6gasOsDTPW%2Fewa5uP9BbdMF%2FySPudPiuyP1%2FjdOILG97p2BUNgqIAABaPc%2FJpH53a4btFSjHwcrXk%2B1nVl%2FQVS3Wb0oNWZm7kVJXNJyl3WDuIOvWbfKeouL8Y0AspBeQ5%2FVnPhzv82pW3A9GDd5HNk80TNknOUCx4PR6zp6i4shPaH%2F2rJzqRp4JLfWLHiLlNkYOrMe2IxhKlGo07ya9xIFzz0ELLA6UJt49Edvfa9tTKzm3d4capfXphDYjX3wQgz6gOMb2Tsy0%2FD4Z8cGrcZP8Os%2B0VU8MDzi14OBzy8XLX6Y19s0lDqyiUiznjeeFAlLPa8P1Ok32hL3fKDlTLvlaettJbwxxCguIIACBAyHJLY%2Fltp6KS8dpGryUr9vVbxDXygiKnFJKFFMj6BCiV6VQ8kHf93cbcvyzGfnvzuOsnh72oC0BQFAAAQHaexZdsTIY80e%2B5pjrsm0Hk0W7b3WHhtohLstyGIFbNGASslAKv5plyNnBzuc4gZSLyxeeP%2B%2FNzLYZKAARFAQAA9M%2FReYOhCqsVyrvonaNzjlpB7wphccpEc9HQxlBvap%2BlXl%2BaLpBMu6856%2Bag7LGdS%2F73G7P8ZJGpCgD%2FD%2Ffbv1cjCgq6AAAAAElFTkSuQmCC"></a>
  <a href="http://daisy.ece.ucdavis.edu:8080/job/gunrock/job/master/"><img src="http://daisy.ece.ucdavis.edu:8080/buildStatus/icon?job=gunrock/master" alt="Build Status"></a>
  <br>
  <a href="https://github.com/gunrock/gunrock/blob/master/LICENSE.TXT"><img src="https://img.shields.io/github/license/gunrock/gunrock.svg" alt="Apache 2"></a>
  <a href="https://github.com/gunrock/gunrock/issues"><img src="https://img.shields.io/github/issues/gunrock/gunrock.svg" alt="Issues Open"></a>
  <a href="https://codecov.io/gh/gunrock/gunrock"><img src="https://codecov.io/gh/gunrock/gunrock/branch/master/graph/badge.svg" /></a>
  <br>
  <a href="https://developer.nvidia.com/gpu-accelerated-libraries"><img src="https://img.shields.io/badge/nvidia-accelerated%20library-green.svg?logo=nvidia" alt="NVIDIA Accelerated Libraries"></a>
  <a href="https://rapids.ai/community.html"><img src="https://img.shields.io/badge/rapids-contributor-%237400ff.svg" alt="RAPIDS"></a>
</p>

<h1 id="gunrock-gpu-graph-analytics" align="center">Gunrock: GPU Graph Analytics</h1>

<!-- end: gunrock's header -->

<p><strong>Gunrock</strong> is a CUDA library for graph-processing designed specifically for the GPU. It uses a <strong>high-level</strong>, <strong>bulk-synchronous</strong>, <strong>data-centric abstraction</strong> focused on operations on a vertex or edge frontier. Gunrock achieves a balance between performance and expressiveness by coupling high performance GPU computing primitives and optimization strategies with a high-level programming model that allows programmers to quickly develop new graph primitives with small code size and minimal GPU programming knowledge. For more details, see <a href="http://gunrock.github.io/docs/#overview">Gunrock's Overview</a>.</p>

<table><thead>
<tr>
<th><strong>Service</strong></th>
<th><strong>System</strong></th>
<th><strong>Environment</strong></th>
<th><strong>Status</strong></th>
</tr>
</thead><tbody>
<tr>
<td><a href="https://jenkins.io/">Jenkins</a></td>
<td>Ubuntu 18.04.2 LTS</td>
<td>CUDA 10.1, NVIDIA Driver 418.39, GCC/G++ 7.3</td>
<td><a href="http://daisy.ece.ucdavis.edu:8080/blue/organizations/jenkins/gunrock/activity"><img src="http://daisy.ece.ucdavis.edu:8080/buildStatus/icon?job=gunrock/master" alt="Build Status"></a></td>
</tr>
</tbody></table>
<h2 id='quick-start-guide'>Quick Start Guide</h2>
<p>Before building Gunrock make sure you have <strong>CUDA 7.5 or higher</strong> (recommended CUDA 9 or higher) installed on your Linux system. We also support building Gunrock on docker images using the provided docker files under <code>docker</code> subdirectory. For complete build guide, see <a href="https://gunrock.github.io/docs/#building-gunrock">Building Gunrock</a>.</p>
<pre class="highlight shell tab-shell"><code>git clone --recursive https://github.com/gunrock/gunrock/
<span class="nb">cd </span>gunrock
mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake .. <span class="o">&amp;&amp;</span> make -j<span class="k">$(</span>nproc<span class="k">)</span>
make <span class="nb">test</span>
</code></pre><h2 id='getting-started-with-gunrock'>Getting Started with Gunrock</h2>
<ul>
<li>To learn more about Gunrock and its programming model, see <a href="http://gunrock.github.io/docs/#overview">Gunrock's Overview</a>.</li>
<li>For information on building Gunrock, see <a href="http://gunrock.github.io/docs/#building-gunrock">Building Gunrock</a>.</li>
<li>Tutorial: <a href="https://gunrock.github.io/docs/developers.html">How to write a graph primitive within Gunrock?</a></li>
<li>Comprehensive <a href="https://gunrock.github.io/docs/#gunrock-39-s-application-cases">list</a> of test applications and primitives for most the functionality of Gunrock.</li>
<li><a href="http://gunrock.github.io/gunrock">API Reference documentation</a> (generated using doxygen).</li>
<li>Find our <a href="http://gunrock.github.io/docs/#publications">publications</a>, <a href="http://gunrock.github.io/docs/#presentations">presentations</a>, and <a href="http://gunrock.github.io/docs/#results-and-analysis">results and analysis</a>.</li>
</ul>
<h2 id='copyright-and-license'>Copyright and License</h2>
<p>Gunrock is copyright The Regents of the University of California, 2013&ndash;2019. The library, examples, and all source code are released under <a href="https://github.com/gunrock/gunrock/blob/master/LICENSE.TXT">Apache 2.0</a>.</p>
<h1 id='building-gunrock'>Building Gunrock</h1>
<p>Gunrock's current release has been tested on Linux Mint 15 (64-bit), Ubuntu 12.04, 14.04 and 15.10 with CUDA 7.5 installed, compute architecture 3.0 and g++ 4.8. We expect Gunrock to build and run correctly on other 64-bit and 32-bit Linux distributions, Mac OS, and Windows.</p>
<h2 id='installation'>Installation</h2>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#hardware">Hardware</a></li>
</ul>
<h2 id='prerequisites'>Prerequisites</h2>
<p><strong>Required Dependencies:</strong></p>

<ul>
<li><p><a href="https://developer.nvidia.com/cuda-zone">CUDA</a> (7.5 or higher) is used to implement Gunrock.</p>

<ul>
<li>Refer to NVIDIA's <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a> homepage to download and install CUDA.</li>
<li>Refer to NVIDIA <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA C Programming Guide</a> for detailed information and examples on programming CUDA.</li>
</ul></li>
<li><p><a href="http://www.boost.org/users/history/version_1_58_0.html">Boost</a> (1.58 or higher) is used for for the CPU reference implementations of Connected Component, Betweenness Centrality, PageRank, Single-Source Shortest Path, and Minimum Spanning Tree.</p>

<ul>
<li>Refer to Boost <a href="http://www.boost.org/doc/libs/1_58_0/more/getting_started/unix-variants.html">Getting Started Guide</a> to install the required Boost libraries.</li>
<li>Alternatively, you can also install Boost by running <code>/gunrock/dep/install_boost.sh</code> script (recommended installation method).</li>
<li>Ideal location for Boost installation is <code>/usr/local/</code>. If the build cannot find your Boost library, make sure a symbolic link for boost installation exists somewhere in <code>/usr/</code> directory.</li>
</ul></li>
<li><p><a href="https://github.com/moderngpu/moderngpu">ModernGPU</a> and <a href="http://nvlabs.github.io/cub/">CUB</a> used as external submodules for Gunrock's APIs.</p>

<ul>
<li>You will need to download or clone ModernGPU and CUB, and place them to <code>gunrock/externals</code></li>
<li>Alternatively, you can clone gunrock recursively with <code>git clone --recursive https://github.com/gunrock/gunrock</code></li>
<li>or if you already cloned gunrock, under <code>gunrock/</code> directory: run <code>git submodule init</code> and
<code>git submodule update</code></li>
</ul></li>
</ul>

<p><strong>Optional Dependencies:</strong></p>

<ul>
<li><a href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview">METIS</a> is used as one possible partitioner to partition graphs for multi-gpu primitives implementations.

<ul>
<li>Refer to METIS <a href="http://glaros.dtc.umn.edu/gkhome/metis/metis/download">Installation Guide</a></li>
<li>Alternatively, you can also install METIS by running <code>/gunrock/dep/install_metis.sh</code> script.</li>
<li>If the build cannot find your METIS library, please set the <code>METIS_DLL</code> environment variable to the full path of the library.</li>
</ul></li>
</ul>
<h2 id='compilation'>Compilation</h2>
<p><strong>Simple Gunrock Compilation:</strong></p>

<blockquote>
<p>Downloading gunrock</p>
</blockquote>
<pre class="highlight shell tab-shell"><code><span class="c"># Using git (recursively) download gunrock</span>
git clone --recursive https://github.com/gunrock/gunrock
<span class="c"># Using wget to download gunrock</span>
wget --no-check-certificate https://github.com/gunrock/gunrock/archive/master.zip
</code></pre>
<blockquote>
<p>Compiling gunrock</p>
</blockquote>
<pre class="highlight shell tab-shell"><code><span class="nb">cd </span>gunrock
mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake ..
make
</code></pre>
<ul>
<li>Binary test files are available in <code>build/bin</code> directory.</li>
<li>You can either run the test for all primitives by typing <code>make check</code> or <code>ctest</code> in the build directory, or do your own testings manually.</li>
<li>Detailed test log from <code>ctest</code> can be found in <code>/build/Testing/Temporary/LastTest.log</code>, alternatively you can run tests with verbose option enabled <code>ctest -v</code>.</li>
</ul>

<p><strong>Advance Gunrock Compilation:</strong></p>

<p>You can also compile gunrock with more specific/advanced settings using <code>cmake -D[OPTION]=ON/OFF</code>. Following options are available:</p>

<ul>
<li><strong>GUNROCK_BUILD_LIB</strong> (default: ON) - Builds main gunrock library.</li>
<li><strong>GUNROCK_BUILD_SHARED_LIBS</strong> (default: ON) - Turn off to build for static libraries.</li>
<li><strong>GUNROCK_BUILD_APPLICATIONS</strong> (default: ON) - Set off to only build one of the following primitive (GUNROCK_APP_* must be set on to build if this option is turned off.)</li>
</ul>

<blockquote>
<p>Example for compiling gunrock with only <em>Breadth First Search (BFS)</em> primitive</p>
</blockquote>
<pre class="highlight shell tab-shell"><code>mkdir build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake -DGUNROCK_BUILD_APPLICATIONS<span class="o">=</span>OFF -DGUNROCK_APP_BFS<span class="o">=</span>ON ..
make
</code></pre>
<ul>
<li><strong>GUNROCK_APP_BC</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_BFS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_CC</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_PR</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_SSSP</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_DOBFS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_HITS</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_SALSA</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_MST</strong> (default: OFF)</li>
<li><strong>GUNROCK_APP_WTF</strong> (default: OFF)</li>
<li><p><strong>GUNROCK_APP_TOPK</strong> (default: OFF)</p>

<ul>
<li><strong>GUNROCK_MGPU_TESTS</strong> (default: OFF) - If on, tests multiple GPU primitives with <code>ctest</code>.</li>
<li><strong>GUNROCK_GENCODE_SM<></strong> (default: GUNROCK_GENCODE_SM30,35,61=ON) change to generate code for a different compute capability.</li>
<li><strong>CUDA_VERBOSE_PTXAS</strong> (default: OFF) - ON to enable verbose output from the PTXAS assembler.</li>
</ul></li>
</ul>
<h2 id='generating-datasets'>Generating Datasets</h2>
<p>All dataset-related code is under the <code>gunrock/dataset/</code> subdirectory. The current version of Gunrock only supports <a href="http://math.nist.gov/MatrixMarket/formats.html">Matrix-market coordinate-formatted graph</a> format. The datasets are divided into two categories according to their scale. Under the <code>dataset/small/</code> subdirectory, there are trivial graph datasets for testing the correctness of the graph primitives. All of them are ready to use. Under the <code>dataset/large/</code> subdirectory, there are large graph datasets for doing performance regression tests.
* To download them to your local machine, just type <code>make</code> in the <code>dataset/large/</code> subdirectory.
* You can also choose to only download one specific dataset to your local machine by stepping into the subdirectory of that dataset and typing make inside that subdirectory.</p>
<h2 id='hardware'>Hardware</h2>
<p><strong>Laboratory Tested Hardware:</strong> Gunrock with GeForce GTX 970, Tesla K40s. We have not encountered any trouble in-house with devices with CUDA capability >= 3.0.</p>
<h1 id='why-gunrock'>Why Gunrock?</h1>
<p>Gunrock is a stable, powerful, and forward-looking substrate for GPU-based graph-centric research and development. Like many graph frameworks, it leverages a bulk-synchronous programming model and targets iterative convergent graph computations. We believe that today Gunrock offers both the best performance on GPU graph analytics as well as the widest range of primitives.</p>

<ul>
<li><p><strong>Gunrock has the best performance of any programmable GPU+graph library.</strong> Gunrock primitives are an order of magnitude faster than  (CPU-based) Boost, outperform any other programmable GPU-based system, and are comparable in performance to hardwired GPU graph primitive implementations. When  compared to <a href="https://github.com/jshun/ligra">Ligra</a>, a best-of-breed CPU system, Gunrock currently  matches or exceeds Ligra's 2-CPU performance with only one GPU.</p>

<p>Gunrock's abstraction separates its programming model from the  low-level implementation details required to make a GPU  implementation run fast. Most importantly, Gunrock features very   powerful load-balancing capabilities that effectively address the   inherent irregularity in graphs, which is a problem we must address   in all graph analytics. We have spent significant effort developing   and optimizing these features---when we beat hardwired analytics,   the reason is load balancing---and because they are beneath the   level of the programming model, improving them makes all graph   analytics run faster without needing to expose them to programmers.</p></li>
<li><p><strong>Gunrock's data-centric programming model is targeted at GPUs and offers advantages over other programming models.</strong> Gunrock is written in a higher-level abstraction than hardwired implementations, leveraging reuse of its fundamental operations across different graph primitives. Gunrock has a bulk-synchronous programming model that operates on a frontier of vertices or edges; unlike other GPU-based graph analytic programming models, Gunrock focuses not on sequencing <em>computation</em> but instead on sequencing <em>operations on frontier data structures</em>. This model has two main operations: <em>compute</em>, which performs a computation on every element in the current frontier, and <em>traversal</em>, which generates a new frontier from the current frontier. Traversal operations include <em>advance</em> (the new frontier is based on the neighbors of the current frontier) and <em>filter</em> (the new frontier is a programmable subset of the current frontier). We are also developing new Gunrock operations on frontier data structures, including neighbor, gather-reduce, and global operations.</p>

<p>This programming model is a better fit to high-performance GPU implementations than traditional programming models adapted from CPUs. Specifically, traditional models like gather-apply-scatter (GAS) map to a suboptimal set of GPU kernels that do a poor job of capturing producer-consumer locality. With Gunrock, we can easily integrate compute steps within the same kernels as traversal steps. As well, Gunrock's frontier-centric programming model is a better match for key optimizations such as push-pull direction-optimal search or priority queues, which to date have not been implemented in other GPU frameworks, where they fit poorly into the abstraction.</p></li>
<li><p><strong>Gunrock supports more primitives than any other programmable GPU+graph library.</strong> We currently support a wide variety of graph primitives, including traversal-based (breadth-first search, single-source shortest path); node-ranking (HITS, SALSA, PageRank); and global (connected component, minimum spanning tree). Many more algorithms are under active development (including graph coloring, maximal independent set, community detection, and graph matching).</p></li>
<li><p><strong>Gunrock has better scalability with multiple GPUs on a node than any other graph library.</strong> We not only show <a href="http://arxiv.org/abs/1504.04804">better BFS performance on a single node than any other GPU framework</a> but also outperform other frameworks, even those customized to BFS, with up to four times as many GPUs. More importantly, our framework supports all Gunrock graph primitives rather than being customized to only one primitive.</p></li>
<li><p><strong>Gunrock's programming model scales to multiple GPUs while still using the same code as a single-GPU primitive.</strong> Other frameworks require rewriting their primitives when moving from one to many GPUs. Gunrock's multi-GPU programming model uses single-node Gunrock code at its core so that single-GPU and multi-GPU operations can share the same codebase.</p></li>
</ul>
<h1 id='methodology-for-graph-analytics-performance'>Methodology for Graph Analytics Performance</h1>
<p>We welcome comments from others on the methodology that we use for measuring Gunrock's performance.</p>

<p>Currently, Gunrock is a library that requires no preprocessing. By this we mean that Gunrock inputs graphs in a "standard" format, e.g., compressed sparse row or coordinate, such as those available on common graph repositories (<a href="https://snap.stanford.edu/data/index.html">SNAP</a> or <a href="http://www.cise.ufl.edu/research/sparse/matrices/">SuiteSparse (UF)</a>). In our experiments, we use <a href="https://people.sc.fsu.edu/~jburkardt/data/mm/mm.html">MatrixMarket</a> format.</p>

<p>Other graph libraries may benefit from preprocessing of input datasets. We would regard any manipulation of the input dataset (e.g., reordering the input or more sophisticated preprocessing such as graph coloring or  <a href="http://farkhor.github.io/CuSha/">CuSha</a>'s G-Shards) to be preprocessing. We think preprocessing is an interesting future direction for Gunrock, but have not yet investigated it. We hope that any graph libraries that do preprocessing report results with both preprocessed and unmodified input datasets.</p>

<p>(That being said, we do standardize input graphs in two ways: before running our experiments, we remove self-loops/duplicated edges. If the undirected flag is set, we convert the input graph to undirected. When we do so, that implies one edge in each direction, and we report edges for that graph accordingly. What we do here appears to be standard practice.)</p>

<p>In general, we try to report results in two ways:</p>

<ul>
<li>Throughput, measured in edges traversed per second (TEPS). We generally use millions of TEPS (MTEPS) as our figure of merit.</li>
<li>Runtime, typically measured in ms. We measure runtime entirely on the GPU, with the expectation that the input data is already on the GPU and the output data will be stored on the GPU. This ignores transfer times (either disk to CPU or CPU to GPU), which are independent of the graph analytics system. It is our expectation that GPU graph analytics will be most effective when (a) they are run on complex primitives and/or (b) run on sequences of primitives, either of which would mitigate transfer times. GPU graph analytics are likely not well suited to running one single simple primitive; for a simple primitive like BFS, it is more expensive to transfer the graph from CPU to GPU than it is to complete the BFS.</li>
</ul>

<p>To calculate TEPS, we require the number of edges traversed (touched), which we count dynamically. For traversal primitives, we note that non-connected components will not be visited, so the number of visited edges may be fewer than the number of edges in the graph. We note that precisely counting edges during the execution of a particular primitive may have performance implications, so we may approximate (see BFS).</p>

<p>Notes on specific primitives follow.</p>
<h2 id='bfs'>BFS</h2>
<p>When we count the number of edges traversed, we do so by summing the number of outbound edges for each visited vertex. For forward, non-idempotent BFS, this strategy should give us an exact count, since this strategy visits every edge incident to a visited vertex. When we enable idempotence, we may visit a node more than once and hence may visit an edge more than once. For backward (pull) BFS, when we visit a vertex, we count all edges incoming to that vertex even if we find a visited predecessor before traversing all edges (and terminate early). (To do so otherwise has performance implications.) Enterprise uses the same counting strategy.</p>

<p>If a comparison library does not measure MTEPS for BFS, we compute it by the number of edges visited divided by runtime; if the former is not available, we use Gunrock's edges-visited count.</p>
<h2 id='sssp'>SSSP</h2>
<p>In general we find MTEPS comparisons between different approaches to SSSP not meaningful: because an edge may be visited one or many times, there is no standard way to count edges traversed. Different algorithms may not only visit a very different number of edges (Dijkstra vs. Bellman-Ford will have very different edge visit counts) but may also have a different number of edges visited across different invocations of the same primitive.</p>

<p>When we report Gunrock's SSSP MTEPS, we use the number of edges queued as the edge-traversal count.</p>

<p>To have a meaningful SSSP experiment, it is critical to have varying edge weights. SSSP measured on uniform edge weights is not meaningful (it becomes BFS). In our experiments, we set edge weights randomly/uniformly between 1 and 64.</p>
<h2 id='bc'>BC</h2>
<p>If a comparison library does not measure MTEPS for BC, we compute it by twice the number of edges visited in the forward phase divided by runtime (the same computation we use for Gunrock).</p>
<h2 id='pagerank'>PageRank</h2>
<p>We measure PageRank elapsed time on one iteration of PageRank. (Many other engines measure results this way and it is difficult to extrapolate from this measurement to runtime of the entire algorithm.)</p>
<h1 id='programming-model'>Programming Model</h1>
<p>This page describes the programming model we use in Gunrock.</p>

<p>Gunrock targets graph computations that are generally expressed as "iterative convergent processes". By "iterative," we mean operations that may require running a series of steps repeatedly; by "convergent," we mean that these iterations allow us to approach the correct answer and terminate when that answer is reached. Many graph-computation programming models target a similar goal.</p>

<p>Many of these programming models focus on sequencing steps of <em>computation</em>.  Gunrock differs from these programming models in its focus on <em>manipulating a data structure</em>. We call this data structure a <em>frontier</em> of vertices or edges. The frontier represents the subset of vertices or edges that is actively participating in the computation. Gunrock operators input one or more frontiers and output one or more frontiers.</p>

<p>Generically, graph operations can often be expressed via a <em>push</em> abstraction (graph elements "push" local private updates into a shared state) or a <em>pull</em> abstraction (graph elements "pull" updates into their local private state) (<a href="https://htor.inf.ethz.ch/publications/index.php?pub=281">Besta et al. publication on push-vs.-pull, HPDC '17</a>). Gunrock's programming model supports both of these abstractions. (For instance, Gunrock's direction-optimized breadth-first-search supports both push and pull BFS phases. <a href="https://github.com/gunrock/mini">Mini-Gunrock</a> supports pull-based BFS and PR.) Push-based approaches may or may not require synchronization (such as atomics) for correct operation; this depends on the primitive. Gunrock's idempotence optimization (within its BFS implementation) is an example of a push-based primitive that does not require atomics.</p>
<h2 id='operators'>Operators</h2>
<p>In the current Gunrock release, we support four operators.</p>

<ul>
<li><p>Advance: An <em>advance</em> operator generates a new frontier from the current frontier by visiting the neighbors of the current frontier. A frontier can consist of either vertices or edges, and an advance step can input and output either kind of frontier. Advance is an irregularly-parallel operation for  two reasons: 1)~different vertices in a graph have different numbers of neighbors and 2)~vertices share neighbors. Thus a vertex in an input frontier map to multiple output items. An efficient advance is the most significant challenge of a GPU implementation.</p></li>
<li><p>Filter:  A <em>filter</em> operator generates a new frontier from the current frontier by choosing a subset of the current frontier based on programmer-specified criteria. Each input item maps to zero or one output items.</p></li>
<li><p>Compute: A <em>compute</em> operator defines an operation on all elements (vertices or edges) in its input frontier. A programmer-specified compute operator can be used together with all three traversal operators. Gunrock performs that operation in parallel across all elements without regard to order.</p></li>
<li><p>Segmented intersection: A <em>segmented intersection</em> operator takes two input node frontiers with the same length, or an input edge frontier, and generates both the number of total intersections and the intersected node IDs as the
new frontier.</p></li>
</ul>

<p>We note that compute operators can often be fused with a neighboring operator into a single kernel. This increases producer-consumer locality and improves performance. Thus within Gunrock, we express compute operators as "functors", which are automatically merged into their neighboring operators. Within Gunrock, we express functors in one of two flavors:</p>

<ul>
<li><p>Cond Functor:
Cond functors input either a vertex id (as in <code>VertexCond</code>) or the source id
and the dest id of an edge (as in <code>EdgeCond</code>). They also input data specific to
the problem being solved to decide whether the vertex or the edge is valid in
the outgoing frontier.</p></li>
<li><p>Apply Functor:
Apply functors take the same set of arguments as Cond functors, but perform
user-specified computation on the problem-specific data.</p></li>
</ul>
<h2 id='creating-a-new-graph-primitive'>Creating a New Graph Primitive</h2>
<p>To create a new graph primitive, we first put all the problem-specific data
into a data structure. For BFS, we need a per-node label value and a per-node
predecessor value; for CC, we need a per-edge mark value, a per-node component
id value, etc. Then we map the algorithm into the combination of the above
three operators. Next, we need to write different functors for these operators.
Some graph algorithms require only one functor (BFS), but some graph algorithms
need more (CC needs seven). Finally, we write an enactor to load the proper
operator with the proper functor. We provide a graph primitive template. The
problem, functor, and enactor files are under gunrock/app/sample, and the
driver code is under tests/sample.</p>
<h1 id='git-forking-workflow'>Git Forking Workflow</h1>
<p>Transitioning over from <a href="http://nvie.com/posts/a-successful-git-branching-model/">Git Branching Workflow</a> suggested by Vincent Driessen at nvie to <a href="https://www.atlassian.com/git/tutorials/comparing-workflows#forking-workflow">Git Forking Workflow</a> for Gunrock.</p>
<h2 id='how-forking-workflow-works'>How Forking Workflow Works?</h2>
<p><img src="https://wac-cdn.atlassian.com/dam/jcr:5c0941ff-a8b5-435b-a092-2167705f1e97/01.svg?cdnVersion=hp" alt="Forking Workflow" />
As in the other Git workflows, the Forking Workflow begins with an <strong>official public repository</strong> stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.
<br><br>Instead, they <strong>fork the official repository</strong> to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can <strong>pull changes</strong> from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a git clone to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.
<br><br> When they're ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The <strong>pull request also serves as a convenient discussion thread</strong> if there are issues with the contributed code.
<br><br> To integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into his local master branch, then pushes the master branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.</p>
<h2 id='gunrock-39-s-forking-workflow'>Gunrock's Forking Workflow:</h2>
<p><strong>gunrock/gunrock:</strong></p>

<ul>
<li><strong>Master Branch:</strong> Reserved only for final releases or some bug fixes/patched codes.</li>
<li><strong>Dev Branch:</strong> Current working branch where all developers push their changes to. This dev branch will serve as the "next release" gunrock, eliminating the need of managing individual branches for each feature and merging them when it is time for the release.</li>
</ul>

<p><strong>personal-fork/gunrock</strong></p>

<ul>
<li><strong>Feature Branch:</strong> This is the developer's personal repository with their feature branch. Whatever changes they would like to contribute to gunrock must be in their own personal fork. And once it is time to create a pull request, it is done so using github pull request, a reviewer checks it and the changes are merged into gunrock/gunrock dev branch.</li>
</ul>

<p>Note that transitioning to this type of workflow from branching model doesn't require much effort, we will just have to start working on our forks and start creating pull requests to one dev branch.</p>
<h2 id='how-to-contribute'>How to contribute?</h2>
<ul>
<li>Fork using GitHub; https://github.com/gunrock/gunrock</li>
<li><code>git clone --recursive https://github.com/gunrock/gunrock.git</code></li>
<li><code>git remote set-url --push origin https://github.com/username/gunrock.git</code> This insures that you are pulling from <code>gunrock/gunrock</code> (staying updated with the main repository) but pushing to your own fork <code>username/gunrock</code>.</li>
<li><code>git add <filename></code></li>
<li><code>git commit -m "Describe your changes."</code></li>
<li><code>git push</code></li>
<li>Once you've pushed the changes on your fork, you can create a <strong>pull request</strong> on Github to merge the changes.</li>
<li>Pull request will then be reviewed and merged into the <code>dev</code> branch.</li>
</ul>
<h1 id='googletest-for-gunrock'>GoogleTest for Gunrock</h1>
<p><strong>Recommended Read:</strong> <a href="https://github.com/google/googletest/blob/master/googletest/docs/Primer.md">Introduction: Why Google C++ Testing Framework?</a></p>

<p>When writing a good test, we would like to cover all possible functions (or execute all code lines),
what I will recommend to do is write a simple test, run code coverage on it, and
use codecov.io to determine what lines are not executed. This gives you a good
idea of what needs to be in the test and what you are missing.</p>

<p><strong>What is code coverage?</strong></p>

<blockquote>
<p>Code coverage is a measurement used to express which lines of code were executed by a test suite. We use three primary terms to describe each lines executed.</p>

<ul>
<li>hit indicates that the source code was executed by the test suite.</li>
<li>partial indicates that the source code was not fully executed by the test suite; there are remaining branches that were not executed.</li>
<li>miss indicates that the source code was not executed by the test suite.</li>
</ul>

<p>Coverage is the ratio of hits / (hit + partial + miss). A code base that has 5 lines executed by tests out of 12 total lines will receive a coverage ratio of 41% (rounding down).</p>
</blockquote>

<p>Below is an example of what lines are a hit and a miss; you can target the lines missed in the tests to improve coverage.</p>

<p><img src="https://i.imgur.com/5QwKjcB.png" alt="Example CodeCov Stats" /></p>
<h2 id='example-test-using-googletest'>Example Test Using GoogleTest</h2><pre class="highlight c tab-c"><code><span class="cm">/**
 * @brief BFS test for shared library advanced interface
 * @file test_lib_bfs.h
 */</span>

<span class="c1">// Includes required for the test
</span>
<span class="cp">#include "stdio.h"
#include "gunrock/gunrock.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
</span>
<span class="c1">// Add to gunrock's namespace
</span><span class="n">namespace</span> <span class="n">gunrock</span> <span class="p">{</span>

<span class="cm">/* Test function, test suite in this case is
 * sharedlibrary and the test itself is breadthfirstsearch
 */</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">sharedlibrary</span><span class="p">,</span> <span class="n">breadthfirstsearch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">GRTypes</span> <span class="n">data_t</span><span class="p">;</span>                 <span class="c1">// data type structure
</span>    <span class="n">data_t</span><span class="p">.</span><span class="n">VTXID_TYPE</span> <span class="o">=</span> <span class="n">VTXID_INT</span><span class="p">;</span>         <span class="c1">// vertex identifier
</span>    <span class="n">data_t</span><span class="p">.</span><span class="n">SIZET_TYPE</span> <span class="o">=</span> <span class="n">SIZET_INT</span><span class="p">;</span>         <span class="c1">// graph size type
</span>    <span class="n">data_t</span><span class="p">.</span><span class="n">VALUE_TYPE</span> <span class="o">=</span> <span class="n">VALUE_INT</span><span class="p">;</span>         <span class="c1">// attributes type
</span>    <span class="kt">int</span> <span class="n">srcs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>

    <span class="k">struct</span> <span class="n">GRSetup</span> <span class="o">*</span><span class="n">config</span> <span class="o">=</span> <span class="n">InitSetup</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">srcs</span><span class="p">);</span>   <span class="c1">// gunrock configurations
</span>
    <span class="kt">int</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">num_edges</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>  <span class="c1">// number of nodes and edges
</span>    <span class="kt">int</span> <span class="n">row_offsets</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">col_indices</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

    <span class="k">struct</span> <span class="n">GRGraph</span> <span class="o">*</span><span class="n">grapho</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">GRGraph</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">GRGraph</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">GRGraph</span> <span class="o">*</span><span class="n">graphi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">GRGraph</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">GRGraph</span><span class="p">));</span>
    <span class="n">graphi</span><span class="o">-></span><span class="n">num_nodes</span>   <span class="o">=</span> <span class="n">num_nodes</span><span class="p">;</span>
    <span class="n">graphi</span><span class="o">-></span><span class="n">num_edges</span>   <span class="o">=</span> <span class="n">num_edges</span><span class="p">;</span>
    <span class="n">graphi</span><span class="o">-></span><span class="n">row_offsets</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">row_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">graphi</span><span class="o">-></span><span class="n">col_indices</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">col_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">gunrock_bfs</span><span class="p">(</span><span class="n">grapho</span><span class="p">,</span> <span class="n">graphi</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">data_t</span><span class="p">);</span>

    <span class="kt">int</span> <span class="o">*</span><span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">graphi</span><span class="o">-></span><span class="n">num_nodes</span><span class="p">);</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">grapho</span><span class="o">-></span><span class="n">node_value1</span><span class="p">;</span>

    <span class="c1">// IMPORTANT: Expected output is stored in an array to compare against determining if the test passed or failed
</span>    <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2147483647</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o"><</span> <span class="n">graphi</span><span class="o">-></span><span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// IMPORTANT: Compare expected result with the generated labels
</span>      <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o"><<</span> <span class="s">"Vectors x and y differ at index "</span> <span class="o"><<</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">graphi</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">graphi</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">grapho</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">grapho</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">labels</span><span class="p">);</span>

<span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace gunrock
</span></code></pre>
<ol>
<li><p>Create a <code>test_<test-name>.h</code> file and place it in the appropriate directory inside <code>/path/to/gunrock/tests/</code>. I will be using <code>test_bfs_lib.h</code> as an example.</p></li>
<li><p>In the <code>tests/test.cpp</code> file, add your test file as an include: <code>#include "bfs/test_lib_bfs.h"</code>.</p></li>
<li><p>In your <code>test_<test-name>.h</code> file, create a <code>TEST()</code> function, which takes two parameters: <code>TEST(<nameofthesuite>, <nameofthetest>)</code>.</p></li>
<li><p>Use <code>EXPECT</code> and <code>ASSERT</code> to write the actual test itself. I have provided a commented example below:</p></li>
<li><p>Now when you run the binary called <code>unit_test</code>, it will automatically run your test suite along with all other google tests as well.
This binary it automatically compiled when gunrock is built, and is found in <code>/path/to/builddir/bin/unit_test</code>.</p></li>
</ol>

<p><strong>Final Remarks:</strong></p>

<ul>
<li>I highly recommend reading the Primer document mentioned at the start of this tutorial. It explains in detail how to write a unit test using google test. My tutorial has more been about how to incorporate it into Gunrock.</li>
<li>Another interesting read is <a href="https://testing.googleblog.com/2014/07/measuring-coverage-at-google.html">Measuring Coverage at Google</a>.</li>
</ul>
<h1 id='road-map'>Road Map</h1>
<ul>
<li><p><strong>Framework:</strong> We are exploring more operators such as neighborhood
reduction and segmented intersection. Generally we want to find the right set of operators that can abstract most graph primitives while delivering high performance.</p></li>
<li><p><strong>API:</strong> We would like to make an API refactoring to simplify parameter passing and to isolate parts of the library that dependencies are not necessary. The target is to make the frontier concept more clear, and to promote code reuse.</p></li>
<li><p><strong>Primitives:</strong> Our near-term goal is to graduate several primitives in dev branch including A* search, weighted label propagation, subgraph matching, triangle counting, and clustering coefficients; implement maximal independent set, max flow, and graph coloring algorithms, build better support for bipartite graph algorithms, and explore community detection algorithms. Our long term goals include algorithms on dynamic graphs, multi-level priority queue support, graph partitioning, and more flexible and scalable multi-GPU algorithms.</p></li>
</ul>
<h1 id='possible-gunrock-projects'>Possible Gunrock projects</h1>
<p>Possible projects are in two categories: infrastructure projects that make Gunrock better but have minimal research value, and research projects that are longer-term and hopefully have research implications of use to the community.</p>

<p>For any discussion on these, please use the existing Github issue (or make one).</p>
<h2 id='infrastructure-projects'>Infrastructure projects</h2>
<ul>
<li>Containerize Gunrock (a Docker container) [<a href="https://github.com/gunrock/gunrock/issues/349">issue</a>]</li>
<li>Support a Windows build [<a href="https://github.com/gunrock/gunrock/issues/213">issue</a>]</li>
<li>Develop a procedure to go from "How does Gunrock do on dataset X" to actually getting results and the right command lines for dataset X. Right now we do this manually with lots of iterations every time. We can automate and document this much better.</li>
<li>Many apps have minimal documentation; we need better text when a user runs <code>./bin/primitive --help</code>.</li>
</ul>
<h2 id='research-projects'>Research projects</h2>
<ul>
<li>Better defaults and/or decision procedures for setting Gunrock parameters (possibly a machine-learning approach for this)</li>
<li>How can we preprocess Gunrock input to increase performance? This could be either reordering CSR for better performance (e.g., reverse Cuthill-McKee) or a new format. Note <a href="https://ieeexplore.ieee.org/document/8573478">When is Graph Reordering an Optimization? Studying the Effect of Lightweight Graph Reordering Across Applications and Input Graphs</a>.</li>
<li>If we had a larger number of X in the hardware&mdash;e.g., more registers, more SMs, more threads/SM, more shared memory, bigger cache---how would it help performance? (Where would we want NVIDIA to spend more transistors to best help our performance?)</li>
<li>How much locality is there in frontiers with respect to the "active" frontier vs. the entire set of vertices? Interesting visualization project, for instance: Get a list of the active vertices in a frontier as a function of iteration, so iteration 0 is vertex set A, iteration 1 is vertex set B, etc. For one iteration, visualize the vertex set as a color per chunk of vertices, say, 1024 vertices per pixel. If all 1024 vertices are part of that frontier, the pixel is white, if 0 black, and gray in between. Then each iteration makes another row of pixels. This shows three things: (a) how many vertices are in the frontier compared to not; (b) how much spatial locality there is; (c) how the frontier evolves over time. One of the goals of this effort would be to determine how useful it would be to do some reordering of vertices either statically or dynamically, and either locally (within a chunk of vertices) or globally.</li>
</ul>
<h1 id='gunrock-v0-5-release-notes'>Gunrock v0.5 Release Notes</h1>
<p>Release 0.5, Upcoming</p>

<p>Release 0.5 is mainly a API refactor, with some feature updates:</p>

<ul>
<li>New operator interfaces</li>
<li>New graph representations</li>
<li>New frontier structure</li>
<li>New test driver</li>
<li>Restructured enactor routines</li>
<li>New parameter handling</li>
<li>New 1D operators</li>
<li>Other code restructuring</li>
<li>Optional Boost dependency</li>
</ul>
<h2 id='changelog'>ChangeLog</h2>
<ul>
<li><p>Operators (i.e. advance, filter)</p>

<ul>
<li>Take in lambda functions for per-element operations, instead of static
functions in a structure. <code><algo>_functor.cuh</code> is merged into
<code><algo>_enactor.cuh</code></li>
<li>Use <code>OprtrParameters</code> structure to keep inputs, except for the graph,
input / output frontiers, and the lambdas</li>
<li><code>KernelPolicy</code> is defined within each operator, instead of in the enactor</li>
<li>Templatized options (Idempotence, mark-preds, advance types, reduce ops,
reduce types, etc.) are provided as a combined 32bit <code>OprtrFlag</code></li>
<li>Queue index and selector are automatically changed by the operator when
needed</li>
</ul></li>
<li><p>Graph representation</p>

<ul>
<li>A single structure encloses all graph related data</li>
<li>Different representations (CSR, CSC, COO, etc.) can be selected based
on algorithmic needs</li>
<li>New graph representations could be added without changing other parts of
Gunrock, except operator implementation that handles how to traverse such
new representation</li>
<li>CPU, GPU and sub-graphs use the same graph data structure, no more
<code>GraphSlice</code> and <code>GRGraph</code></li>
</ul></li>
<li><p>Frontier</p>

<ul>
<li>A single structure <code>gunrock/app/frontier.cuh:Frontier</code>
encloses all frontier related data</li>
</ul></li>
<li><p>Test driver</p>

<ul>
<li>Allows multiple graph types (<code>64bit-VertexT</code>, <code>64bit-SizeT</code>,
<code>64bit-ValueT</code>, directed vs. undirected) and multiple parameters
combinations to run in a single execution</li>
<li>Allows result validation for each run, instead of only the last run</li>
<li>Result validation without reference for BFS and SSSP</li>
<li>Moved common functions into <code>gunrock/app/test_base.cuh</code></li>
<li>Moved CPU reference code and result validation into
<code>gunrock/app/<algo>/<algo>_test.cuh</code></li>
</ul></li>
<li><p>Enactor</p>

<ul>
<li>Common functions moved into <code>gunrock/app/enactor_base.cuh</code></li>
<li>Use OpenMP to maintain controlling threads on CPU</li>
<li>Use instances of <code>Iteration</code> instead of static access to its functions</li>
</ul></li>
<li><p>Command line parameters</p>

<ul>
<li>A dedicated <code>Parameters</code> struct to store all running parameters</li>
<li>Need to define parameters via. <code>Use</code> function before using them</li>
<li>Command line is parsed by <code>get_opt</code></li>
<li><code>Set</code> to set parameter values</li>
<li><code>Get</code> to get parameter values</li>
<li>Handles vectors as parameter values</li>
</ul></li>
<li><p>1D operators for Array1D</p>

<ul>
<li>Per-element operations, e.g. <code>ForAll</code> and <code>ForEach</code></li>
<li>Vector-Vector operations, e.g. <code>Add</code>, <code>Minus</code>, <code>Mul</code>, <code>Div</code>, <code>Mad</code>, <code>Set</code></li>
<li>Vector-Scalar operations</li>
<li>Sort</li>
</ul></li>
<li><p>Code restructuring</p>

<ul>
<li>Partitioners moved from <code>gunrock/app</code> to <code>gunrock/partitioner</code></li>
<li><code>LB</code> operator moved from <code>gunrock/oprtr/edge_map_partitioned_forward</code> to
<code>gunrock/oprtr/LB_advance</code></li>
<li><code>TWC</code> operator moved from 'gunrock/oprtr/edge_map_forward' to
<code>gunrock/oprtr/TWC_advance</code></li>
</ul></li>
<li><p>Optional Boost dependency</p>

<ul>
<li>Utility functions changed to C++11 or implemented</li>
<li>CPU references implemented for BFS and SSSP, and will be called when BOOST
is not available</li>
<li><code>info</code> will use RapidJson-based implementation, when Boost is not available</li>
</ul></li>
</ul>
<h2 id='known-issues'>Known Issues</h2>
<ul>
<li>Multi-GPU framework not tested</li>
<li>Operators have decreased performance, due to more than 32 registers used by
a single thread in the kernels</li>
<li>RGG and GRMAT generators not working</li>
<li>SSSP may have incorrect predecessors, due to data racing in marking the
predecessors within the operator kernels</li>
</ul>
<h1 id='frequently-asked-questions'>Frequently Asked Questions</h1>
<p>Some of the most common questions we have come across during the life of Gunrock project. If your question isn't already answered below, feel free to create an <a href="https://github.com/gunrock/gunrock/issues">issue</a> on GitHub.</p>
<h2 id='what-does-it-do'>What does it do?</h2>
<p>Gunrock is a fast and efficient graph processing library on the GPU that
provides a set of graph algorithms used in big data analytics and visualization
with high performance.  It also provides a set of operators which abstract the
general operations in graph processing for other developers to build
high-performance graph algorithm prototypes with minimum programming effort.</p>
<h2 id='how-does-it-do-it'>How does it do it?</h2>
<p>Gunrock takes advantage of the immense computational power available in
commodity-level, off-the-shelf Graphics Processing Units (GPUs), originally
designed to handle the parallel computational tasks in computer graphics, to
perform graph traversal and computation in parallel on thousands of GPU's
computing cores.</p>
<h2 id='who-should-want-this'>Who should want this?</h2>
<p>Gunrock is built with two kinds of users in mind: The first kind of users are
programmers who build big graph analytics and visualization projects and need to
use existing graph primitives provided by Gunrock.  The second kind of users
are programmers who want to use Gunrock's high-level, programmable abstraction
to express, develop, and refine their own (and often more complicated) graph
primitives.</p>
<h2 id='what-is-the-skill-set-users-need-to-use-it'>What is the skill set users need to use it?</h2>
<p>For the first kind of users, C/C++ background is sufficient. We are also
building Gunrock as a shared library with C interfaces that can be loaded by
other languages such as Python and Julia.  For the second kind of users, they
need to have the C/C++ background and also an understanding of parallel
programming, especially BSP (Bulk-Synchronous Programming) model used by Gunrock.</p>
<h2 id='what-platforms-languages-do-people-need-to-know-in-order-to-modify-or-integrate-it-with-other-tools'>What platforms/languages do people need to know in order to modify or integrate it with other tools?</h2>
<p>Using the exposed interface, the users do not need to know CUDA or OpenCL to
modify or integrate Gunrock to their own tools. However, an essential
understanding of parallel programming and BSP model is necessary if one wants
to add/modify graph primitives in Gunrock.</p>
<h2 id='why-would-someone-want-this'>Why would someone want this?</h2>
<p>The study of social networks, webgraphs, biological networks, and unstructured
meshes in scientific simulation has raised a significant demand for efficient
parallel frameworks for processing and analytics on large-scale graphs. Initial
research efforts in using GPUs for graph processing and analytics are promising.</p>
<h2 id='how-is-it-better-than-the-current-state-of-the-art'>How is it better than the current state of the art?</h2>
<p>Most existing CPU large graph processing libraries perform worse on large
graphs with billions of edges. Supercomputer or expensive clusters can achieve
close to real-time feedback with high cost on hardware infrastructure. With
GPUs, we can achieve the same real-time feedback with much lower cost on
hardware. Gunrock has the best performance among the limited research efforts
toward GPU graph processing. Our peak Edge Traversed Per Second (ETPS) can
reach 3.5G.  And all the primitives in Gunrock have 10x to 25x speedup over the
equivalent single-node CPU implementations. With a set of general graph
processing operators exposed to users, Gunrock is also more flexible than other
GPU/CPU graph library in terms of programmability.</p>
<h2 id='how-would-someone-get-it'>How would someone get it?</h2>
<p>Gunrock is an open-source library. The code, documentation, and quick start
guide are all on its <a href="gunrock.github.io">GitHub page</a>.</p>
<h2 id='is-a-user-account-required'>Is a user account required?</h2>
<p>No. One can use either git clone or download directly to get the source code
and documentation of Gunrock.</p>
<h2 id='are-all-of-its-components-dependencies-easy-to-find'>Are all of its components/dependencies easy to find?</h2>
<p>Gunrock has three dependencies. Two of them are also GPU primitive libraries which
also reside on GitHub. The third one is Boost (Gunrock uses Boost Graph Library
to implement CPU reference testing algorithms). All dependencies do not require
installation. To use, one only needs to download or git clone them and put them
in the according directories. More details in the installation section of this
documentation.</p>
<h2 id='how-would-someone-install-it'>How would someone install it?</h2>
<p>For C/C++ programmer, integrating Gunrock into your projects is easy. Since it
is a template based library, just add the include files in your code. The
simple example and all the testrigs will provide detailed information on how to
do this.</p>

<p>For programmers who use Python, Julia, or other language and want to call
Gunrock APIs, we are building a shared library with binary compatible
C interfaces. It will be included in the soon-to-arrive next release of
Gunrock.</p>
<h2 id='can-anyone-install-it-do-they-need-it-help'>Can anyone install it? Do they need IT help?</h2>
<p>Gunrock is targeted at developers who are familiar with basic software
engineering. For non-technical people, IT help might be needed.</p>
<h2 id='does-this-process-actually-work-all-the-time-on-all-systems-specified'>Does this process actually work? All the time? On all systems specified?</h2>
<p>Currently, Gunrock has been tested on two Linux distributions: Linux Mint and
Ubuntu. But we expect it to run correctly on other Linux distributions too.
We are currently building a CMake solution to port Gunrock to Mac and Windows.
The feature will be included in the soon-to-arrive next release of Gunrock.</p>
<h2 id='how-would-someone-test-that-it-39-s-working-with-provided-sample-data'>How would someone test that it's working with provided sample data?</h2>
<p>Testrigs are provided as well as a small simple example for users to test the
correctness and performance of every graph primitive.</p>
<h2 id='is-the-quot-using-quot-of-sample-data-clear'>Is the "using" of sample data clear?</h2>
<p>On Linux, one only needs to go to the dataset directory and run "make"; the
script will automatically download all the needed datasets. One can also choose
to download a single dataset in its separate directory.</p>
<h2 id='how-would-someone-use-it-with-their-own-data'>How would someone use it with their own data?</h2>
<p>Gunrock supports Matrix Market (.mtx) file format; users need to pre-process
the graph data into this format before running Gunrock.</p>

      </div>

      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
